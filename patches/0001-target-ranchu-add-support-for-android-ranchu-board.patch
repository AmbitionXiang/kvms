From 5af18e56c3b6ec85db82285dfcc68470a7db71b6 Mon Sep 17 00:00:00 2001
From: Janne Karhunen <Janne.Karhunen@gmail.com>
Date: Wed, 26 May 2021 15:49:22 +0300
Subject: [PATCH] target/ranchu: add support for android 'ranchu' board

The board is used by Google to run the Android emulation for
the Android SDK. The code itself is originally from linaro
and it's a forked 'virt' with relevant Android devices added.
This patch lifts the code used by Google in QEMU 2.12 fork
to modern QEMU (6.0+). The code is a rought prototype.

Status:
- board declaration ok
- moved to gicv3 (for kvm/hardware invocation)
- framebuffer ported

Signed-off-by: Janne Karhunen <Janne.Karhunen@gmail.com>
---
 default-configs/devices/arm-softmmu.mak   |   1 +
 hw/arm/Kconfig                            |  32 +
 hw/arm/meson.build                        |   1 +
 hw/arm/ranchu.c                           | 729 ++++++++++++++++++++++
 hw/display/Kconfig                        |   3 +
 hw/display/goldfish_fb.c                  | 549 ++++++++++++++++
 hw/display/meson.build                    |   1 +
 include/hw/display/goldfish_fb.h          |  25 +
 include/hw/display/goldfish_fb_template.h |  93 +++
 include/sysemu/ranchu.h                   |  41 ++
 10 files changed, 1475 insertions(+)
 create mode 100644 hw/arm/ranchu.c
 create mode 100644 hw/display/goldfish_fb.c
 create mode 100644 include/hw/display/goldfish_fb.h
 create mode 100644 include/hw/display/goldfish_fb_template.h
 create mode 100644 include/sysemu/ranchu.h

diff --git a/default-configs/devices/arm-softmmu.mak b/default-configs/devices/arm-softmmu.mak
index 0500156a0c..00a7be4c26 100644
--- a/default-configs/devices/arm-softmmu.mak
+++ b/default-configs/devices/arm-softmmu.mak
@@ -7,6 +7,7 @@ CONFIG_ARM_V7M=y
 # CONFIG_TEST_DEVICES=n
 
 CONFIG_ARM_VIRT=y
+CONFIG_ARM_RANCHU=y
 CONFIG_CUBIEBOARD=y
 CONFIG_EXYNOS4=y
 CONFIG_HIGHBANK=y
diff --git a/hw/arm/Kconfig b/hw/arm/Kconfig
index 8c37cf00da..5f71537662 100644
--- a/hw/arm/Kconfig
+++ b/hw/arm/Kconfig
@@ -29,6 +29,38 @@ config ARM_VIRT
     select ACPI_NVDIMM
     select ACPI_APEI
 
+config ARM_RANCHU
+    bool
+    imply PCI_DEVICES
+    imply TEST_DEVICES
+    imply VFIO_AMD_XGBE
+    imply VFIO_PLATFORM
+    imply VFIO_XGMAC
+    imply TPM_TIS_SYSBUS
+    select ARM_GIC
+    select ACPI
+    select ARM_SMMUV3
+    select GPIO_KEY
+    select FW_CFG_DMA
+    select PCI_EXPRESS
+    select PCI_EXPRESS_GENERIC_BRIDGE
+    select PFLASH_CFI01
+    select PL011 # UART
+    select PL031 # RTC
+    select PL061 # GPIO
+    select GPIO_PWR
+    select PLATFORM_BUS
+    select SMBIOS
+    select VIRTIO_MMIO
+    select ACPI_PCI
+    select MEM_DEVICE
+    select DIMM
+    select ACPI_MEMORY_HOTPLUG
+    select ACPI_HW_REDUCED
+    select ACPI_NVDIMM
+    select ACPI_APEI
+    select GOLDFISH_FB
+
 config CHEETAH
     bool
     select OMAP
diff --git a/hw/arm/meson.build b/hw/arm/meson.build
index be39117b9b..50346c2d07 100644
--- a/hw/arm/meson.build
+++ b/hw/arm/meson.build
@@ -2,6 +2,7 @@ arm_ss = ss.source_set()
 arm_ss.add(files('boot.c'), fdt)
 arm_ss.add(when: 'CONFIG_PLATFORM_BUS', if_true: files('sysbus-fdt.c'))
 arm_ss.add(when: 'CONFIG_ARM_VIRT', if_true: files('virt.c'))
+arm_ss.add(when: 'CONFIG_ARM_RANCHU', if_true: files('ranchu.c'))
 arm_ss.add(when: 'CONFIG_ACPI', if_true: files('virt-acpi-build.c'))
 arm_ss.add(when: 'CONFIG_DIGIC', if_true: files('digic_boards.c'))
 arm_ss.add(when: 'CONFIG_EXYNOS4', if_true: files('exynos4_boards.c'))
diff --git a/hw/arm/ranchu.c b/hw/arm/ranchu.c
new file mode 100644
index 0000000000..39499f5964
--- /dev/null
+++ b/hw/arm/ranchu.c
@@ -0,0 +1,729 @@
+/*
+ * ARM Android emulator 'ranchu' board.
+ *
+ * Copyright (c) 2014 Linaro Limited
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Emulate a virtual board for use as part of the Android emulator.
+ * We create a device tree to pass to the kernel.
+ * The board has a mixture of virtio devices and some Android-specific
+ * devices inherited from the 32 bit 'goldfish' board.
+ *
+ * We only support 64-bit ARM CPUs.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "hw/arm/primecell.h"
+#include "hw/arm/boot.h"
+#include "migration/vmstate.h"
+#include "hw/char/pl011.h"
+#include "net/net.h"
+#include "sysemu/device_tree.h"
+#include "sysemu/ranchu.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/kvm.h"
+#include "hw/boards.h"
+#include "hw/intc/arm_gicv3_common.h"
+#include "exec/address-spaces.h"
+#include "qemu/bitops.h"
+#include "qemu/error-report.h"
+#include "qemu/config-file.h"
+#include "chardev/char.h"
+#include "monitor/monitor.h"
+#include "qapi/error.h"
+
+#define NUM_VIRTIO_TRANSPORTS 32
+
+/* Number of external interrupt lines to configure the GIC with */
+#define NUM_IRQS 128
+
+#define GIC_FDT_IRQ_TYPE_SPI 0
+#define GIC_FDT_IRQ_TYPE_PPI 1
+
+#define GIC_FDT_IRQ_FLAGS_EDGE_LO_HI 1
+#define GIC_FDT_IRQ_FLAGS_EDGE_HI_LO 2
+#define GIC_FDT_IRQ_FLAGS_LEVEL_HI 4
+#define GIC_FDT_IRQ_FLAGS_LEVEL_LO 8
+
+#define GIC_FDT_IRQ_PPI_CPU_START 8
+#define GIC_FDT_IRQ_PPI_CPU_WIDTH 8
+
+enum {
+    RANCHU_FLASH,
+    RANCHU_MEM,
+    RANCHU_CPUPERIPHS,
+    RANCHU_GIC_DIST,
+    RANCHU_GIC_CPU,
+    RANCHU_GIC_V2M,
+    RANCHU_GIC_HYP,
+    RANCHU_GIC_VCPU,
+    RANCHU_GIC_ITS,
+    RANCHU_GIC_REDIST,
+    RANCHU_UART,
+    RANCHU_GOLDFISH_FB,
+    RANCHU_GOLDFISH_BATTERY,
+    RANCHU_GOLDFISH_AUDIO,
+    RANCHU_GOLDFISH_EVDEV,
+    RANCHU_GOLDFISH_PIPE,
+    RANCHU_GOLDFISH_SYNC,
+    RANCHU_MMIO,
+};
+
+typedef struct VirtBoardInfo {
+    struct arm_boot_info bootinfo;
+    const char *cpu_model;
+    const MemMapEntry *memmap;
+    const int *irqmap;
+    int smp_cpus;
+    void *fdt;
+    int fdt_size;
+    uint32_t clock_phandle;
+    uint32_t gic_phandle;
+    uint32_t msi_phandle;
+    bool virt;
+    bool secure;
+    DeviceState *gic;
+    MachineState *ms;
+} VirtBoardInfo;
+
+/* Addresses and sizes of our components.
+ * 0..128MB is space for a flash device so we can run bootrom code such as UEFI.
+ * 128MB..256MB is used for miscellaneous device I/O.
+ * 256MB..1GB is reserved for possible future PCI support (ie where the
+ * PCI memory window will go if we add a PCI host controller).
+ * 1GB and up is RAM (which may happily spill over into the
+ * high memory region beyond 4GB).
+ * This represents a compromise between how much RAM can be given to
+ * a 32 bit VM and leaving space for expansion and in particular for PCI.
+ * Note that generally devices should be placed at multiples of 0x10000
+ * to allow for the possibility of the guest using 64K pages.
+ */
+static const MemMapEntry memmap[] = {
+    /* Space up to 0x8000000 is reserved for a boot ROM */
+    [RANCHU_FLASH] = { 0, 0x8000000 },
+    [RANCHU_CPUPERIPHS] = { 0x8000000, 0x20000 },
+
+    /* GIC distributor and CPU interfaces sit inside the CPU peripheral space */
+    [RANCHU_GIC_DIST] =           { 0x08000000, 0x00010000 },
+    [RANCHU_GIC_CPU] =            { 0x08010000, 0x00010000 },
+    [RANCHU_GIC_V2M] =            { 0x08020000, 0x00001000 },
+    [RANCHU_GIC_HYP] =            { 0x08030000, 0x00010000 },
+    [RANCHU_GIC_VCPU] =           { 0x08040000, 0x00010000 },
+    /* The space in between here is reserved for GICv3 CPU/vCPU/HYP */
+    [RANCHU_GIC_ITS] =            { 0x08080000, 0x00020000 },
+    /* This redistributor space allows up to 2*64kB*123 CPUs */
+    [RANCHU_GIC_REDIST] =         { 0x080A0000, 0x00F60000 },
+    [RANCHU_UART] = { 0x9000000, 0x1000 },
+    [RANCHU_GOLDFISH_FB] = { 0x9010000, 0x100 },
+    [RANCHU_GOLDFISH_BATTERY] = { 0x9020000, 0x1000 },
+    [RANCHU_GOLDFISH_AUDIO] = { 0x9030000, 0x100 },
+    [RANCHU_GOLDFISH_EVDEV] = { 0x9040000, 0x1000 },
+    [RANCHU_MMIO] = { 0xa000000, 0x200 },
+    [RANCHU_GOLDFISH_PIPE] = {0xa010000, 0x2000 },
+    [RANCHU_GOLDFISH_SYNC] = {0xa020000, 0x2000 },
+    /* ...repeating for a total of NUM_VIRTIO_TRANSPORTS, each of that size */
+    /* 0x10000000 .. 0x40000000 reserved for PCI */
+    [RANCHU_MEM] = { 0x40000000, 30ULL * 1024 * 1024 * 1024 },
+};
+
+static const int irqmap[] = {
+    [RANCHU_UART] = 1,
+    [RANCHU_GOLDFISH_FB] = 2,
+    [RANCHU_GOLDFISH_BATTERY] = 3,
+    [RANCHU_GOLDFISH_AUDIO] = 4,
+    [RANCHU_GOLDFISH_EVDEV] = 5,
+    [RANCHU_GOLDFISH_PIPE] = 6,
+    [RANCHU_GOLDFISH_SYNC] = 7,
+    [RANCHU_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
+};
+
+static QemuDeviceTreeSetupFunc device_tree_setup_func;
+void qemu_device_tree_setup_callback(QemuDeviceTreeSetupFunc setup_func)
+{
+    device_tree_setup_func = setup_func;
+}
+
+static void create_fdt(VirtBoardInfo *vbi)
+{
+    void *fdt = create_device_tree(&vbi->fdt_size);
+
+    if (!fdt) {
+        error_report("create_device_tree() failed");
+        exit(1);
+    }
+
+    vbi->fdt = fdt;
+    vbi->ms->fdt = fdt;
+
+    /* Header */
+    qemu_fdt_setprop_string(fdt, "/", "compatible", "ranchu");
+    qemu_fdt_setprop_cell(fdt, "/", "#address-cells", 0x2);
+    qemu_fdt_setprop_cell(fdt, "/", "#size-cells", 0x2);
+
+    /* Firmware node */
+    qemu_fdt_add_subnode(fdt, "/firmware");
+    qemu_fdt_add_subnode(fdt, "/firmware/android");
+    qemu_fdt_setprop_string(fdt, "/firmware/android", "compatible", "android,firmware");
+    qemu_fdt_setprop_string(fdt, "/firmware/android", "hardware", "ranchu");
+
+    if (device_tree_setup_func) {
+        device_tree_setup_func(fdt);
+    }
+
+    /*
+     * /chosen and /memory nodes must exist for load_dtb
+     * to fill in necessary properties later
+     */
+    qemu_fdt_add_subnode(fdt, "/chosen");
+    qemu_fdt_add_subnode(fdt, "/memory");
+    qemu_fdt_setprop_string(fdt, "/memory", "device_type", "memory");
+
+    /* Clock node, for the benefit of the UART. The kernel device tree
+     * binding documentation claims the PL011 node clock properties are
+     * optional but in practice if you omit them the kernel refuses to
+     * probe for the device.
+     */
+    vbi->clock_phandle = qemu_fdt_alloc_phandle(fdt);
+    qemu_fdt_add_subnode(fdt, "/apb-pclk");
+    qemu_fdt_setprop_string(fdt, "/apb-pclk", "compatible", "fixed-clock");
+    qemu_fdt_setprop_cell(fdt, "/apb-pclk", "#clock-cells", 0x0);
+    qemu_fdt_setprop_cell(fdt, "/apb-pclk", "clock-frequency", 24000000);
+    qemu_fdt_setprop_string(fdt, "/apb-pclk", "clock-output-names",
+                                "clk24mhz");
+    qemu_fdt_setprop_cell(fdt, "/apb-pclk", "phandle", vbi->clock_phandle);
+
+    /* No PSCI for TCG yet */
+    if (kvm_enabled()) {
+        uint32_t cpu_suspend_fn;
+        uint32_t cpu_off_fn;
+        uint32_t cpu_on_fn;
+        uint32_t migrate_fn;
+
+        qemu_fdt_add_subnode(fdt, "/psci");
+        const char comp[] = "arm,psci-0.2\0arm,psci";
+        qemu_fdt_setprop(fdt, "/psci", "compatible", comp, sizeof(comp));
+
+        cpu_off_fn = QEMU_PSCI_0_2_FN_CPU_OFF;
+        cpu_suspend_fn = QEMU_PSCI_0_2_FN64_CPU_SUSPEND;
+        cpu_on_fn = QEMU_PSCI_0_2_FN64_CPU_ON;
+        migrate_fn = QEMU_PSCI_0_2_FN64_MIGRATE;
+
+        qemu_fdt_setprop_string(fdt, "/psci", "method", "hvc");
+        qemu_fdt_setprop_cell(fdt, "/psci", "cpu_suspend", cpu_suspend_fn);
+        qemu_fdt_setprop_cell(fdt, "/psci", "cpu_off", cpu_off_fn);
+        qemu_fdt_setprop_cell(fdt, "/psci", "cpu_on", cpu_on_fn);
+        qemu_fdt_setprop_cell(fdt, "/psci", "migrate", migrate_fn);
+    }
+}
+
+static void fdt_add_timer_nodes(const VirtBoardInfo *vbi)
+{
+    /* Note that on A15 h/w these interrupts are level-triggered,
+     * but for the GIC implementation provided by both QEMU and KVM
+     * they are edge-triggered.
+     */
+    uint32_t irqflags = GIC_FDT_IRQ_FLAGS_EDGE_LO_HI;
+
+    irqflags = deposit32(irqflags, GIC_FDT_IRQ_PPI_CPU_START,
+                         GIC_FDT_IRQ_PPI_CPU_WIDTH, (1 << vbi->smp_cpus) - 1);
+
+    qemu_fdt_add_subnode(vbi->fdt, "/timer");
+    qemu_fdt_setprop_string(vbi->fdt, "/timer",
+                                "compatible", "arm,armv7-timer");
+    qemu_fdt_setprop_cells(vbi->fdt, "/timer", "interrupts",
+                               GIC_FDT_IRQ_TYPE_PPI, 13, irqflags,
+                               GIC_FDT_IRQ_TYPE_PPI, 14, irqflags,
+                               GIC_FDT_IRQ_TYPE_PPI, 11, irqflags,
+                               GIC_FDT_IRQ_TYPE_PPI, 10, irqflags);
+}
+
+static void fdt_add_cpu_nodes(const VirtBoardInfo *vbi)
+{
+    int cpu;
+
+    qemu_fdt_add_subnode(vbi->fdt, "/cpus");
+    qemu_fdt_setprop_cell(vbi->fdt, "/cpus", "#address-cells", 0x1);
+    qemu_fdt_setprop_cell(vbi->fdt, "/cpus", "#size-cells", 0x0);
+
+    for (cpu = vbi->smp_cpus - 1; cpu >= 0; cpu--) {
+        char *nodename = g_strdup_printf("/cpus/cpu@%d", cpu);
+        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(cpu));
+
+        qemu_fdt_add_subnode(vbi->fdt, nodename);
+        qemu_fdt_setprop_string(vbi->fdt, nodename, "device_type", "cpu");
+        qemu_fdt_setprop_string(vbi->fdt, nodename, "compatible",
+                                    armcpu->dtb_compatible);
+
+        if (vbi->smp_cpus > 1) {
+            qemu_fdt_setprop_string(vbi->fdt, nodename,
+                                        "enable-method", "psci");
+        }
+
+        qemu_fdt_setprop_cell(vbi->fdt, nodename, "reg", cpu);
+        g_free(nodename);
+    }
+}
+
+/* Return the number of used redistributor regions  */
+static inline int ranchu_gicv3_redist_region_count(const VirtBoardInfo *vbi)
+{
+    uint32_t redist0_capacity =
+                vbi->memmap[RANCHU_GIC_REDIST].size / GICV3_REDIST_SIZE;
+
+    return vbi->ms->smp.cpus > redist0_capacity ? 2 : 1;
+}
+
+static void fdt_add_gic_node(VirtBoardInfo *vms)
+{
+    MachineState *ms = vms->ms;
+    char *nodename;
+    int nb_redist_regions;
+
+    vms->gic_phandle = qemu_fdt_alloc_phandle(ms->fdt);
+    qemu_fdt_setprop_cell(ms->fdt, "/", "interrupt-parent", vms->gic_phandle);
+
+    nodename = g_strdup_printf("/intc@%" PRIx64,
+                               vms->memmap[RANCHU_GIC_DIST].base);
+    qemu_fdt_add_subnode(ms->fdt, nodename);
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "#interrupt-cells", 3);
+    qemu_fdt_setprop(ms->fdt, nodename, "interrupt-controller", NULL, 0);
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "#address-cells", 0x2);
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "#size-cells", 0x2);
+    qemu_fdt_setprop(ms->fdt, nodename, "ranges", NULL, 0);
+
+    nb_redist_regions = ranchu_gicv3_redist_region_count(vms);
+    assert(nb_redist_regions == 1);
+
+    qemu_fdt_setprop_string(ms->fdt, nodename, "compatible",
+                                "arm,gic-v3");
+
+    qemu_fdt_setprop_cell(ms->fdt, nodename,
+                         "#redistributor-regions", nb_redist_regions);
+
+    if (nb_redist_regions == 1) {
+        qemu_fdt_setprop_sized_cells(ms->fdt, nodename, "reg",
+                                     2, vms->memmap[RANCHU_GIC_DIST].base,
+                                     2, vms->memmap[RANCHU_GIC_DIST].size,
+                                     2, vms->memmap[RANCHU_GIC_REDIST].base,
+                                     2, vms->memmap[RANCHU_GIC_REDIST].size);
+    } else {
+        qemu_fdt_setprop_sized_cells(ms->fdt, nodename, "reg",
+                                    2, vms->memmap[RANCHU_GIC_DIST].base,
+                                    2, vms->memmap[RANCHU_GIC_DIST].size,
+                                    2, vms->memmap[RANCHU_GIC_REDIST].base,
+                                    2, vms->memmap[RANCHU_GIC_REDIST].size);
+    }
+
+    if (vms->virt) {
+         qemu_fdt_setprop_cells(ms->fdt, nodename, "interrupts",
+                                GIC_FDT_IRQ_TYPE_PPI, ARCH_GIC_MAINT_IRQ,
+                                GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+    }
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "phandle", vms->gic_phandle);
+    g_free(nodename);
+}
+
+static void fdt_add_its_gic_node(VirtBoardInfo *vbi)
+{
+    MachineState *ms = vbi->ms;
+    char *nodename;
+
+    vbi->msi_phandle = qemu_fdt_alloc_phandle(ms->fdt);
+    nodename = g_strdup_printf("/intc/its@%" PRIx64,
+                               vbi->memmap[RANCHU_GIC_ITS].base);
+    qemu_fdt_add_subnode(ms->fdt, nodename);
+    qemu_fdt_setprop_string(ms->fdt, nodename, "compatible",
+                            "arm,gic-v3-its");
+    qemu_fdt_setprop(ms->fdt, nodename, "msi-controller", NULL, 0);
+    qemu_fdt_setprop_sized_cells(ms->fdt, nodename, "reg",
+                                 2, vbi->memmap[RANCHU_GIC_ITS].base,
+                                 2, vbi->memmap[RANCHU_GIC_ITS].size);
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "phandle", vbi->msi_phandle);
+    g_free(nodename);
+}
+
+static void create_its(VirtBoardInfo *vbi)
+{
+    const char *itsclass = "arm-its-kvm";
+    DeviceState *dev;
+
+    if (!itsclass) {
+        /* Do nothing if not supported */
+        return;
+    }
+
+    dev = qdev_new(itsclass);
+
+    object_property_set_link(OBJECT(dev), "parent-gicv3", OBJECT(vbi->gic),
+                             &error_abort);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, vbi->memmap[RANCHU_GIC_ITS].base);
+
+    fdt_add_its_gic_node(vbi);
+}
+
+static void create_gic(VirtBoardInfo *vbi, qemu_irq *pic)
+{
+    MachineState *ms = vbi->ms;
+    /* We create a standalone GIC */
+    SysBusDevice *gicbusdev;
+    const char *gictype = "kvm-arm-gicv3";
+    int type = 3, i;
+    unsigned int smp_cpus = ms->smp.cpus;
+    uint32_t nb_redist_regions = 0;
+
+    vbi->gic = qdev_new(gictype);
+    qdev_prop_set_uint32(vbi->gic, "revision", type);
+    qdev_prop_set_uint32(vbi->gic, "num-cpu", smp_cpus);
+    /* Note that the num-irq property counts both internal and external
+     * interrupts; there are always 32 of the former (mandated by GIC spec).
+     */
+    qdev_prop_set_uint32(vbi->gic, "num-irq", NUM_IRQS + 32);
+    if (!kvm_irqchip_in_kernel()) {
+        qdev_prop_set_bit(vbi->gic, "has-security-extensions", vbi->secure);
+    }
+
+    if (type == 3) {
+        uint32_t redist0_capacity =
+                    vbi->memmap[RANCHU_GIC_REDIST].size / GICV3_REDIST_SIZE;
+        uint32_t redist0_count = MIN(smp_cpus, redist0_capacity);
+
+        nb_redist_regions = ranchu_gicv3_redist_region_count(vbi);
+        assert(nb_redist_regions == 1);
+
+        qdev_prop_set_uint32(vbi->gic, "len-redist-region-count",
+                             nb_redist_regions);
+        qdev_prop_set_uint32(vbi->gic, "redist-region-count[0]", redist0_count);
+    } else {
+        if (!kvm_irqchip_in_kernel()) {
+            qdev_prop_set_bit(vbi->gic, "has-virtualization-extensions",
+                              vbi->virt);
+        }
+    }
+    gicbusdev = SYS_BUS_DEVICE(vbi->gic);
+    sysbus_realize_and_unref(gicbusdev, &error_fatal);
+    sysbus_mmio_map(gicbusdev, 0, vbi->memmap[RANCHU_GIC_DIST].base);
+    if (type == 3) {
+        sysbus_mmio_map(gicbusdev, 1, vbi->memmap[RANCHU_GIC_REDIST].base);
+    } else {
+        sysbus_mmio_map(gicbusdev, 1, vbi->memmap[RANCHU_GIC_CPU].base);
+        if (vbi->virt) {
+            sysbus_mmio_map(gicbusdev, 2, vbi->memmap[RANCHU_GIC_HYP].base);
+            sysbus_mmio_map(gicbusdev, 3, vbi->memmap[RANCHU_GIC_VCPU].base);
+        }
+    }
+
+    /* Wire the outputs from each CPU's generic timer and the GICv3
+     * maintenance interrupt signal to the appropriate GIC PPI inputs,
+     * and the GIC's IRQ/FIQ/VIRQ/VFIQ interrupt outputs to the CPU's inputs.
+     */
+    for (i = 0; i < smp_cpus; i++) {
+        DeviceState *cpudev = DEVICE(qemu_get_cpu(i));
+        int ppibase = NUM_IRQS + i * GIC_INTERNAL + GIC_NR_SGIS;
+        int irq;
+        /* Mapping from the output timer irq lines from the CPU to the
+         * GIC PPI inputs we use for the virt board.
+         */
+        const int timer_irq[] = {
+            [GTIMER_PHYS] = ARCH_TIMER_NS_EL1_IRQ,
+            [GTIMER_VIRT] = ARCH_TIMER_VIRT_IRQ,
+            [GTIMER_HYP]  = ARCH_TIMER_NS_EL2_IRQ,
+            [GTIMER_SEC]  = ARCH_TIMER_S_EL1_IRQ,
+        };
+
+        for (irq = 0; irq < ARRAY_SIZE(timer_irq); irq++) {
+            qdev_connect_gpio_out(cpudev, irq,
+                                  qdev_get_gpio_in(vbi->gic,
+                                                   ppibase + timer_irq[irq]));
+        }
+
+        if (type == 3) {
+            qemu_irq irq = qdev_get_gpio_in(vbi->gic,
+                                            ppibase + ARCH_GIC_MAINT_IRQ);
+            qdev_connect_gpio_out_named(cpudev, "gicv3-maintenance-interrupt",
+                                        0, irq);
+        } else if (vbi->virt) {
+            qemu_irq irq = qdev_get_gpio_in(vbi->gic,
+                                            ppibase + ARCH_GIC_MAINT_IRQ);
+            sysbus_connect_irq(gicbusdev, i + 4 * smp_cpus, irq);
+        }
+
+        qdev_connect_gpio_out_named(cpudev, "pmu-interrupt", 0,
+                                    qdev_get_gpio_in(vbi->gic, ppibase
+                                                     + VIRTUAL_PMU_IRQ));
+
+        sysbus_connect_irq(gicbusdev, i, qdev_get_gpio_in(cpudev, ARM_CPU_IRQ));
+        sysbus_connect_irq(gicbusdev, i + smp_cpus,
+                           qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));
+        sysbus_connect_irq(gicbusdev, i + 2 * smp_cpus,
+                           qdev_get_gpio_in(cpudev, ARM_CPU_VIRQ));
+        sysbus_connect_irq(gicbusdev, i + 3 * smp_cpus,
+                           qdev_get_gpio_in(cpudev, ARM_CPU_VFIQ));
+    }
+
+    for (i = 0; i < NUM_IRQS; i++)
+        pic[i] = qdev_get_gpio_in(vbi->gic, i);
+
+    fdt_add_gic_node(vbi);
+    create_its(vbi);
+}
+
+static void init_simple_device(DeviceState *dev,
+                               const VirtBoardInfo *vbi,qemu_irq *pic,
+                               int devid, const char *sysbus_name,
+                               const char *compat,
+                               int num_compat_strings,
+                               const char *clocks, int num_clocks)
+{
+    int irq = irqmap[devid];
+    hwaddr base = memmap[devid].base;
+    hwaddr size = memmap[devid].size;
+    char *nodename;
+    int i;
+    int compat_sz = 0;
+    int clocks_sz = 0;
+
+    SysBusDevice *s = SYS_BUS_DEVICE(dev);
+    sysbus_mmio_map(s, 0, base);
+    if (pic[irq]) {
+        sysbus_connect_irq(s, 0, pic[irq]);
+    }
+
+    for (i = 0; i < num_compat_strings; i++) {
+        compat_sz += strlen(compat + compat_sz) + 1;
+    }
+
+    for (i = 0; i < num_clocks; i++) {
+        clocks_sz += strlen(clocks + clocks_sz) + 1;
+    }
+
+    nodename = g_strdup_printf("/%s@%" PRIx64, sysbus_name, base);
+    qemu_fdt_add_subnode(vbi->fdt, nodename);
+    qemu_fdt_setprop(vbi->fdt, nodename, "compatible", compat, compat_sz);
+    qemu_fdt_setprop_sized_cells(vbi->fdt, nodename, "reg", 2, base, 2, size);
+    if (irq) {
+        qemu_fdt_setprop_cells(vbi->fdt, nodename, "interrupts",
+                               GIC_FDT_IRQ_TYPE_SPI, irq,
+                               GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+    }
+    if (num_clocks) {
+        qemu_fdt_setprop_cells(vbi->fdt, nodename, "clocks",
+                               vbi->clock_phandle, vbi->clock_phandle);
+        qemu_fdt_setprop(vbi->fdt, nodename, "clock-names",
+                         clocks, clocks_sz);
+    }
+    g_free(nodename);
+}
+
+/**
+ * create_simple_device:
+ * @vbi: VirtBoardInfo struct
+ * @pic: interrupt array
+ * @devid: the RANCHU_* index for this device
+ * @sysbus_name: QEMU's name for the device
+ * @compat: one or more NUL-separated DTB compat strings
+ * @num_compat_strings: number of NUL-separated strings in @compat
+ * @clocks: zero or more NUL-separated clock names
+ * @num_clocks: number of NUL-separated clock names in @clocks
+ *
+ * Create a simple device with one interrupt and an uncomplicated
+ * device tree node (one reg tuple, one interrupt, optional clocks).
+ */
+static void create_simple_device(const VirtBoardInfo *vbi, qemu_irq *pic,
+                                 int devid, const char *sysbus_name,
+                                 const char *compat, int num_compat_strings,
+                                 const char *clocks, int num_clocks)
+{
+    DeviceState *dev = qdev_new(sysbus_name);
+    init_simple_device(dev, vbi, pic, devid, sysbus_name, compat,
+                       num_compat_strings, clocks, num_clocks);
+}
+
+static void create_serial_device(int serial_index, const VirtBoardInfo *vbi,
+                                 qemu_irq *pic, int devid,
+                                 const char *sysbus_name, const char *compat,
+                                 int num_compat_strings, const char *clocks,
+                                 int num_clocks)
+{
+    DeviceState *dev = qdev_new(sysbus_name);
+    Chardev *d = serial_hd(serial_index);
+    qdev_prop_set_chr(dev, "chardev", d);
+    init_simple_device(dev, vbi, pic, devid, sysbus_name, compat,
+                       num_compat_strings, clocks, num_clocks);
+}
+
+static void create_virtio_devices(const VirtBoardInfo *vbi, qemu_irq *pic)
+{
+    int i;
+    hwaddr size = memmap[RANCHU_MMIO].size;
+
+    /* Note that we have to create the transports in forwards order
+     * so that command line devices are inserted lowest address first,
+     * and then add dtb nodes in reverse order so that they appear in
+     * the finished device tree lowest address first.
+     */
+    for (i = 0; i < NUM_VIRTIO_TRANSPORTS; i++) {
+        int irq = irqmap[RANCHU_MMIO] + i;
+        hwaddr base = memmap[RANCHU_MMIO].base + i * size;
+
+        sysbus_create_simple("virtio-mmio", base, pic[irq]);
+    }
+
+    for (i = NUM_VIRTIO_TRANSPORTS - 1; i >= 0; i--) {
+        char *nodename;
+        int irq = irqmap[RANCHU_MMIO] + i;
+        hwaddr base = memmap[RANCHU_MMIO].base + i * size;
+
+        nodename = g_strdup_printf("/virtio_mmio@%" PRIx64, base);
+        qemu_fdt_add_subnode(vbi->fdt, nodename);
+        qemu_fdt_setprop_string(vbi->fdt, nodename,
+                                "compatible", "virtio,mmio");
+        qemu_fdt_setprop_sized_cells(vbi->fdt, nodename, "reg",
+                                     2, base, 2, size);
+        qemu_fdt_setprop_cells(vbi->fdt, nodename, "interrupts",
+                               GIC_FDT_IRQ_TYPE_SPI, irq,
+                               GIC_FDT_IRQ_FLAGS_EDGE_LO_HI);
+        g_free(nodename);
+    }
+}
+
+static void *ranchu_dtb(const struct arm_boot_info *binfo, int *fdt_size)
+{
+    const VirtBoardInfo *board = (const VirtBoardInfo *)binfo;
+
+    *fdt_size = board->fdt_size;
+    return board->fdt;
+}
+
+#define DEFAULT_ARM_CPU_MODEL "cortex-a15"
+
+static char* splice_out_cpu_model(const char* cpu_type) {
+    // We rely on the model being encoded in the cpu_type, so we validate
+    // the assumption here.
+    assert(cpu_type &&
+           strcmp(cpu_type + (strlen(cpu_type) - strlen(TYPE_ARM_CPU)), TYPE_ARM_CPU) == 0);
+
+    if (!cpu_type) {
+      fprintf(stderr, "%s: WARNING, unknown cpu type, defaulting to cortex-a15\n", __func__);
+      return g_strdup(DEFAULT_ARM_CPU_MODEL);
+    }
+
+    // cpu model is the cpy type minus the ARM postfix.
+    return g_strndup(cpu_type, strlen(cpu_type) - strlen(TYPE_ARM_CPU) - 1);
+}
+
+static void ranchu_init(MachineState *machine)
+{
+    qemu_irq pic[NUM_IRQS];
+    MemoryRegion *sysmem = get_system_memory();
+    int n;
+    MemoryRegion *ram = g_new(MemoryRegion, 1);
+    VirtBoardInfo *vbi;
+    int smp_cpus = machine->smp.cpus;
+
+    // Cpu type contains cpu model, so we have to splice it out.
+    char *cpu_model = splice_out_cpu_model(machine->cpu_type);
+
+    vbi = g_new0(VirtBoardInfo, 1);
+
+    if (machine->ram_size > memmap[RANCHU_MEM].size) {
+        error_report("ranchu: cannot model more than 30GB RAM");
+        exit(1);
+    }
+
+    vbi->ms = machine;
+    vbi->memmap = memmap;
+    create_fdt(vbi);
+    fdt_add_timer_nodes(vbi);
+
+    for (n = 0; n < smp_cpus; n++) {
+        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);
+        Object *cpuobj;
+
+        if (!oc) {
+            fprintf(stderr, "Unable to find CPU definition\n");
+            exit(1);
+        }
+        cpuobj = object_new(object_class_get_name(oc));
+
+        /* Secondary CPUs start in PSCI powered-down state */
+        if (n > 0) {
+            object_property_set_bool(cpuobj, "start-powered-off", true, NULL);
+        }
+        if (object_property_find(cpuobj, "reset-cbar")) {
+            object_property_set_int(cpuobj, "reset-cbar",
+                                    memmap[RANCHU_CPUPERIPHS].base,
+                                    &error_abort);
+        }
+
+        object_property_set_bool(cpuobj, "realized", true, NULL);
+    }
+    fdt_add_cpu_nodes(vbi);
+
+    memory_region_init_ram_nomigrate(ram, NULL, "ranchu.ram", machine->ram_size,
+                           &error_abort);
+    vmstate_register_ram_global(ram);
+    memory_region_add_subregion(sysmem, memmap[RANCHU_MEM].base, ram);
+
+    create_gic(vbi, pic);
+    create_serial_device(0, vbi, pic, RANCHU_UART, "pl011",
+                         "arm,pl011\0arm,primecell", 2, "uartclk\0apb_pclk", 2);
+    create_simple_device(vbi, pic, RANCHU_GOLDFISH_FB, "goldfish_fb",
+                         "google,goldfish-fb\0"
+                         "generic,goldfish-fb", 2, 0, 0);
+    create_simple_device(vbi, pic, RANCHU_GOLDFISH_BATTERY, "goldfish_battery",
+                         "google,goldfish-battery\0"
+                         "generic,goldfish-battery", 2, 0, 0);
+    create_simple_device(vbi, pic, RANCHU_GOLDFISH_AUDIO, "goldfish_audio",
+                         "google,goldfish-audio\0"
+                         "generic,goldfish-audio", 2, 0, 0);
+    create_simple_device(vbi, pic, RANCHU_GOLDFISH_EVDEV, "goldfish-events",
+                         "google,goldfish-events-keypad\0"
+                         "generic,goldfish-events-keypad", 2, 0, 0);
+    create_simple_device(vbi, pic, RANCHU_GOLDFISH_PIPE, "goldfish_pipe",
+                         "google,android-pipe\0"
+                         "generic,android-pipe", 2, 0, 0);
+    create_simple_device(vbi, pic, RANCHU_GOLDFISH_SYNC, "goldfish_sync",
+                         "google,goldfish-sync\0"
+                         "generic,goldfish-sync", 2, 0, 0);
+
+    /* Create mmio transports, so the user can create virtio backends
+     * (which will be automatically plugged in to the transports). If
+     * no backend is created the transport will just sit harmlessly idle.
+     */
+    create_virtio_devices(vbi, pic);
+
+    vbi->bootinfo.ram_size = machine->ram_size;
+    vbi->bootinfo.kernel_filename = machine->kernel_filename;
+    vbi->bootinfo.kernel_cmdline = machine->kernel_cmdline;
+    vbi->bootinfo.initrd_filename = machine->initrd_filename;
+    vbi->bootinfo.nb_cpus = smp_cpus;
+    vbi->bootinfo.board_id = -1;
+    vbi->bootinfo.loader_start = memmap[RANCHU_MEM].base;
+    vbi->bootinfo.get_dtb = ranchu_dtb;
+    arm_load_kernel(ARM_CPU(first_cpu), machine, &vbi->bootinfo);
+
+    g_free(cpu_model);
+}
+
+static void ranchu_machine_init(MachineClass *mc)
+{
+    mc->desc = "Android/ARM ranchu";
+    mc->init = ranchu_init;
+    mc->max_cpus = 16;
+    mc->is_default = 1;
+}
+
+DEFINE_MACHINE("ranchu", ranchu_machine_init)
diff --git a/hw/display/Kconfig b/hw/display/Kconfig
index ca46b5830e..897d1ce4f1 100644
--- a/hw/display/Kconfig
+++ b/hw/display/Kconfig
@@ -66,6 +66,9 @@ config BOCHS_DISPLAY
     select VGA
     select EDID
 
+config GOLDFISH_FB
+    bool
+
 config BLIZZARD
     bool
 
diff --git a/hw/display/goldfish_fb.c b/hw/display/goldfish_fb.c
new file mode 100644
index 0000000000..57db6b741c
--- /dev/null
+++ b/hw/display/goldfish_fb.c
@@ -0,0 +1,549 @@
+/* Copyright (C) 2007-2013 The Android Open Source Project
+**
+** This software is licensed under the terms of the GNU General Public
+** License version 2, as published by the Free Software Foundation, and
+** may be copied, distributed, and modified under those terms.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+*/
+#include "qemu/osdep.h"
+#include "hw/hw.h"
+#include "hw/sysbus.h"
+#include "ui/console.h"
+#include "framebuffer.h"
+#include "ui/pixel_ops.h"
+#include "trace.h"
+#include "exec/address-spaces.h"
+#include "hw/display/goldfish_fb.h"
+#include "hw/irq.h"
+#include "migration/register.h"
+#include "migration/qemu-file-types.h"
+
+#include <inttypes.h>
+
+static int s_use_host_gpu = 0;
+static int s_display_bpp = 32;
+
+void goldfish_fb_set_use_host_gpu(int enabled) {
+    s_use_host_gpu = enabled;
+}
+
+void goldfish_fb_set_display_depth(int depth) {
+    s_display_bpp = depth;
+}
+
+#define DEST_BITS 8
+#define SOURCE_BITS 16
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 15
+#define SOURCE_BITS 16
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 16
+#define SOURCE_BITS 16
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 24
+#define SOURCE_BITS 16
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 32
+#define SOURCE_BITS 16
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 8
+#define SOURCE_BITS 32
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 15
+#define SOURCE_BITS 32
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 16
+#define SOURCE_BITS 32
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 24
+#define SOURCE_BITS 32
+#include "hw/display/goldfish_fb_template.h"
+#define DEST_BITS 32
+#define SOURCE_BITS 32
+#include "hw/display/goldfish_fb_template.h"
+
+#define TYPE_GOLDFISH_FB "goldfish_fb"
+#define GOLDFISH_FB(obj) OBJECT_CHECK(struct goldfish_fb_state, (obj), TYPE_GOLDFISH_FB)
+/* These values *must* match the platform definitions found under
+ * <system/graphics.h>
+ */
+enum {
+    HAL_PIXEL_FORMAT_RGBA_8888          = 1,
+    HAL_PIXEL_FORMAT_RGBX_8888          = 2,
+    HAL_PIXEL_FORMAT_RGB_888            = 3,
+    HAL_PIXEL_FORMAT_RGB_565            = 4,
+    HAL_PIXEL_FORMAT_BGRA_8888          = 5,
+};
+
+enum {
+    FB_GET_WIDTH        = 0x00,
+    FB_GET_HEIGHT       = 0x04,
+    FB_INT_STATUS       = 0x08,
+    FB_INT_ENABLE       = 0x0c,
+    FB_SET_BASE         = 0x10,
+    FB_SET_ROTATION     = 0x14, /* DEPRECATED */
+    FB_SET_BLANK        = 0x18,
+    FB_GET_PHYS_WIDTH   = 0x1c,
+    FB_GET_PHYS_HEIGHT  = 0x20,
+    FB_GET_FORMAT       = 0x24,
+
+    FB_INT_VSYNC             = 1U << 0,
+    FB_INT_BASE_UPDATE_DONE  = 1U << 1
+};
+
+struct goldfish_fb_state {
+    SysBusDevice parent;
+
+    QemuConsole *con;
+    MemoryRegion iomem;
+    qemu_irq irq;
+
+    uint32_t fb_base;
+    uint32_t base_valid : 1;
+    uint32_t need_update : 1;
+    uint32_t need_int : 1;
+    uint32_t blank : 1;
+    uint32_t int_status;
+    uint32_t int_enable;
+    int      rotation;   /* 0, 1, 2 or 3 */
+    int      dpi;
+    int      format;
+
+    MemoryRegionSection fbsection;
+};
+
+#define  GOLDFISH_FB_SAVE_VERSION  3
+
+/* Console hooks */
+void goldfish_fb_set_rotation(int rotation)
+{
+    DeviceState *dev = qdev_find_recursive(sysbus_get_default(), TYPE_GOLDFISH_FB);
+    if (dev) {
+        struct goldfish_fb_state *s = GOLDFISH_FB(dev);
+        DisplaySurface *ds = qemu_console_surface(s->con);
+        s->rotation = rotation;
+        s->need_update = 1;
+        qemu_console_resize(s->con, surface_height(ds), surface_width(ds));
+    } else {
+        fprintf(stderr,"%s: unable to find FB dev\n", __func__);
+    }
+}
+
+static void goldfish_fb_save(QEMUFile*  f, void*  opaque)
+{
+    struct goldfish_fb_state*  s = opaque;
+
+    DisplaySurface *ds = qemu_console_surface(s->con);
+
+    qemu_put_be32(f, surface_width(ds));
+    qemu_put_be32(f, surface_height(ds));
+    qemu_put_be32(f, surface_stride(ds));
+    qemu_put_byte(f, 0);
+
+    qemu_put_be32(f, s->fb_base);
+    qemu_put_byte(f, s->base_valid);
+    qemu_put_byte(f, s->need_update);
+    qemu_put_byte(f, s->need_int);
+    qemu_put_byte(f, s->blank);
+    qemu_put_be32(f, s->int_status);
+    qemu_put_be32(f, s->int_enable);
+    qemu_put_be32(f, s->rotation);
+    qemu_put_be32(f, s->dpi);
+    qemu_put_be32(f, s->format);
+}
+
+static int  goldfish_fb_load(QEMUFile*  f, void*  opaque, int  version_id)
+{
+    struct goldfish_fb_state*  s   = opaque;
+    int                        ret = -1;
+    int                        ds_w, ds_h, ds_pitch, ds_rot;
+
+    if (version_id != GOLDFISH_FB_SAVE_VERSION)
+        goto Exit;
+
+    ds_w     = qemu_get_be32(f);
+    ds_h     = qemu_get_be32(f);
+    ds_pitch = qemu_get_be32(f);
+    ds_rot   = qemu_get_byte(f);
+
+    DisplaySurface *ds = qemu_console_surface(s->con);
+
+    if (surface_width(ds) != ds_w ||
+        surface_height(ds) != ds_h ||
+        surface_stride(ds) != ds_pitch ||
+        ds_rot != 0)
+    {
+        /* XXX: We should be able to force a resize/rotation from here ? */
+        fprintf(stderr, "%s: framebuffer dimensions mismatch\n", __FUNCTION__);
+        goto Exit;
+    }
+
+    s->fb_base      = qemu_get_be32(f);
+    s->base_valid   = qemu_get_byte(f);
+    s->need_update  = qemu_get_byte(f);
+    s->need_int     = qemu_get_byte(f);
+    s->blank        = qemu_get_byte(f);
+    s->int_status   = qemu_get_be32(f);
+    s->int_enable   = qemu_get_be32(f);
+    s->rotation     = qemu_get_be32(f);
+    s->dpi          = qemu_get_be32(f);
+    s->format       = qemu_get_be32(f);
+
+    /* force a refresh */
+    s->need_update = 1;
+
+    ret = 0;
+Exit:
+    return ret;
+}
+
+static int
+pixels_to_mm(int  pixels, int dpi)
+{
+    /* dpi = dots / inch
+    ** inch = dots / dpi
+    ** mm / 25.4 = dots / dpi
+    ** mm = (dots * 25.4)/dpi
+    */
+    return (int)(0.5 + 25.4 * pixels  / dpi);
+}
+
+
+#define  STATS  0
+
+#if STATS
+static int   stats_counter;
+static long  stats_total;
+static int   stats_full_updates;
+static long  stats_total_full_updates;
+#endif
+
+static void goldfish_fb_update_display(void *opaque)
+{
+    struct goldfish_fb_state *s = (struct goldfish_fb_state *)opaque;
+    DisplaySurface *ds = qemu_console_surface(s->con);
+    int full_update = 0;
+
+    if (!s || !s->con || surface_bits_per_pixel(ds) == 0 || !s->fb_base)
+        return;
+
+    if((s->int_enable & FB_INT_VSYNC) && !(s->int_status & FB_INT_VSYNC)) {
+        s->int_status |= FB_INT_VSYNC;
+        qemu_irq_raise(s->irq);
+    }
+
+    if(s->need_update) {
+        full_update = 1;
+        if(s->need_int) {
+            s->int_status |= FB_INT_BASE_UPDATE_DONE;
+            if(s->int_enable & FB_INT_BASE_UPDATE_DONE)
+                qemu_irq_raise(s->irq);
+        }
+        s->need_int = 0;
+        s->need_update = 0;
+    }
+
+    int dest_width = surface_width(ds);
+    int dest_height = surface_height(ds);
+    int dest_pitch = surface_stride(ds);
+    int ymin, ymax;
+
+#if STATS
+    if (full_update)
+        stats_full_updates += 1;
+    if (++stats_counter == 120) {
+        stats_total               += stats_counter;
+        stats_total_full_updates  += stats_full_updates;
+
+        stats_counter      = 0;
+        stats_full_updates = 0;
+    }
+#endif /* STATS */
+
+    if (s->blank)
+    {
+        void *dst_line = surface_data(ds);
+        memset( dst_line, 0, dest_height*dest_pitch );
+        ymin = 0;
+        ymax = dest_height-1;
+    }
+    else
+    {
+        int src_width, src_height;
+        int dest_row_pitch, dest_col_pitch;
+        drawfn fn;
+
+        /* The source framebuffer is always read in a linear fashion,
+         * we achieve rotation by altering the destination
+         * step-per-pixel.
+         */
+        switch (s->rotation) {
+        case 0: /* Normal, native landscape view */
+            src_width = dest_width;
+            src_height = dest_height;
+            dest_row_pitch = surface_stride(ds);
+            dest_col_pitch = surface_bytes_per_pixel(ds);
+            break;
+        case 1: /* 90 degree, portrait view */
+            src_width = dest_height;
+            src_height = dest_width;
+            dest_row_pitch = -surface_bytes_per_pixel(ds);
+            dest_col_pitch = surface_stride(ds);
+            break;
+        case 2: /* 180 degree, inverted landscape view */
+            src_width = dest_width;
+            src_height = dest_height;
+            dest_row_pitch = -surface_stride(ds);
+            dest_col_pitch = -surface_bytes_per_pixel(ds);
+            break;
+        case 3: /* 270 degree, mirror portrait view */
+            src_width = dest_height;
+            src_height = dest_width;
+            dest_row_pitch = surface_bytes_per_pixel(ds);
+            dest_col_pitch = -surface_stride(ds);
+            break;
+        default:
+            g_assert_not_reached();
+        }
+
+        int source_bytes_per_pixel = 2;
+
+        switch (s->format) { /* source format */
+        case HAL_PIXEL_FORMAT_RGB_565:
+            source_bytes_per_pixel = 2;
+            switch (surface_bits_per_pixel(ds)) { /* dest format */
+            case 8:  fn = draw_line_16_8;  break;
+            case 15: fn = draw_line_16_15; break;
+            case 16: fn = draw_line_16_16; break;
+            case 24: fn = draw_line_16_24; break;
+            case 32: fn = draw_line_16_32; break;
+            default:
+                hw_error("goldfish_fb: bad dest color depth\n");
+                return;
+            }
+            break;
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+            source_bytes_per_pixel = 4;
+            switch (surface_bits_per_pixel(ds)) { /* dest format */
+            case 8:  fn = draw_line_32_8;  break;
+            case 15: fn = draw_line_32_15; break;
+            case 16: fn = draw_line_32_16; break;
+            case 24: fn = draw_line_32_24; break;
+            case 32: fn = draw_line_32_32; break;
+            default:
+                hw_error("goldfish_fb: bad dest color depth\n");
+                return;
+            }
+            break;
+        default:
+            hw_error("goldfish_fb: bad source color format\n");
+            return;
+        }
+
+        ymin = 0;
+        // with -gpu on, the following check and return will save 2%
+        // CPU time on OSX; saving on other platforms may differ.
+        if (s_use_host_gpu) return;
+
+        if (full_update) {
+            framebuffer_update_memory_section(
+                    &s->fbsection, get_system_memory(), s->fb_base,
+                    src_height, src_width * source_bytes_per_pixel);
+        }
+        framebuffer_update_display(ds, &s->fbsection,
+                                   src_width, src_height,
+                                   src_width * source_bytes_per_pixel,
+                                   dest_row_pitch, dest_col_pitch,
+                                   full_update,
+                                   fn, ds, &ymin, &ymax);
+    }
+
+    ymax += 1;
+    if (ymin >= 0) {
+        if (s->rotation % 2) {
+            /* In portrait mode we are drawing "sideways" so always
+             * need to update the whole screen */
+            dpy_gfx_update(s->con, 0, 0, dest_width, dest_height);
+
+        } else {
+            dpy_gfx_update(s->con, 0, ymin, dest_width, ymax-ymin);
+        }
+    }
+}
+
+static void goldfish_fb_invalidate_display(void * opaque)
+{
+    // is this called?
+    struct goldfish_fb_state *s = (struct goldfish_fb_state *)opaque;
+    s->need_update = 1;
+}
+
+static uint64_t goldfish_fb_read(void *opaque, hwaddr offset, unsigned size)
+{
+    uint64_t ret = 0;
+    struct goldfish_fb_state *s = opaque;
+    DisplaySurface *ds = qemu_console_surface(s->con);
+
+    if (!s_display_bpp) {
+        s_display_bpp = surface_bits_per_pixel(ds);
+    }
+
+    switch(offset) {
+        case FB_GET_WIDTH:
+            ret = surface_width(ds);
+            break;
+
+        case FB_GET_HEIGHT:
+            ret = surface_height(ds);
+            break;
+
+        case FB_INT_STATUS:
+            ret = s->int_status & s->int_enable;
+            if(ret) {
+                s->int_status &= ~ret;
+                qemu_irq_lower(s->irq);
+            }
+            break;
+
+        case FB_GET_PHYS_WIDTH:
+            ret = pixels_to_mm( surface_width(ds), s->dpi );
+            break;
+
+        case FB_GET_PHYS_HEIGHT:
+            ret = pixels_to_mm( surface_height(ds), s->dpi );
+            break;
+
+        case FB_GET_FORMAT:
+            /* A kernel making this query supports high color and true color */
+            switch (s_display_bpp) {   /* hw.lcd.depth */
+            case 32:
+            case 24:
+               ret = HAL_PIXEL_FORMAT_RGBX_8888;
+               break;
+            case 16:
+               ret = HAL_PIXEL_FORMAT_RGB_565;
+               break;
+            default:
+               error_report("goldfish_fb_read: Bad display bit depth %d",
+                       s_display_bpp);
+               break;
+            }
+            s->format = ret;
+            break;
+
+        default:
+            error_report("goldfish_fb_read: Bad offset 0x" TARGET_FMT_plx,
+                    offset);
+            break;
+    }
+
+    return ret;
+}
+
+static void goldfish_fb_write(void *opaque, hwaddr offset, uint64_t val,
+        unsigned size)
+{
+    struct goldfish_fb_state *s = opaque;
+
+
+    switch(offset) {
+        case FB_INT_ENABLE:
+            s->int_enable = val;
+            qemu_set_irq(s->irq, s->int_status & s->int_enable);
+            break;
+        case FB_SET_BASE:
+            s->fb_base = val;
+            s->int_status &= ~FB_INT_BASE_UPDATE_DONE;
+            s->need_update = 1;
+            s->need_int = 1;
+            s->base_valid = 1;
+            /* The guest is waiting for us to complete an update cycle
+             * and notify it, so make sure we do a redraw immediately.
+             */
+            if (s_use_host_gpu) return;
+
+            graphic_hw_update(s->con);
+            qemu_set_irq(s->irq, s->int_status & s->int_enable);
+            break;
+        case FB_SET_ROTATION:
+            error_report("%s: use of deprecated FB_SET_ROTATION %" PRIu64,
+                         __func__, val);
+            break;
+        case FB_SET_BLANK:
+            s->blank = val;
+            s->need_update = 1;
+            break;
+        default:
+            error_report("goldfish_fb_write: Bad offset 0x" TARGET_FMT_plx,
+                    offset);
+    }
+}
+
+static const MemoryRegionOps goldfish_fb_iomem_ops = {
+    .read = goldfish_fb_read,
+    .write = goldfish_fb_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl.min_access_size = 4,
+    .impl.max_access_size = 4,
+};
+
+static const GraphicHwOps goldfish_fb_ops = {
+    .invalidate = goldfish_fb_invalidate_display,
+    .gfx_update = goldfish_fb_update_display,
+};
+
+static SaveVMHandlers goldfish_vmhandlers= {
+    .save_state = goldfish_fb_save,
+    .load_state = goldfish_fb_load
+};
+
+
+static void goldfish_fb_init(Object *obj)
+{
+    SysBusDevice *sbdev = SYS_BUS_DEVICE(obj);
+    DeviceState *dev = DEVICE(sbdev);
+    struct goldfish_fb_state *s = GOLDFISH_FB(dev);
+
+    dev->id = g_strdup(TYPE_GOLDFISH_FB);
+
+    sysbus_init_irq(sbdev, &s->irq);
+
+    s->con = graphic_console_init(dev, 0, &goldfish_fb_ops, s);
+
+    s->dpi = 165;  /* TODO: Find better way to get actual value ! */
+
+    s->format = HAL_PIXEL_FORMAT_RGB_565;
+
+    memory_region_init_io(&s->iomem, OBJECT(s), &goldfish_fb_iomem_ops, s,
+            "goldfish_fb", 0x100);
+    sysbus_init_mmio(sbdev, &s->iomem);
+
+    register_savevm_live("goldfish_fb", 0, GOLDFISH_FB_SAVE_VERSION,
+                     &goldfish_vmhandlers, s);
+}
+
+static void goldfish_fb_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->desc = "goldfish framebuffer";
+}
+
+static const TypeInfo goldfish_fb_info = {
+    .name          = TYPE_GOLDFISH_FB,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(struct goldfish_fb_state),
+    .instance_init = goldfish_fb_init,
+    .class_init    = goldfish_fb_class_init,
+};
+
+static void goldfish_fb_register(void)
+{
+    type_register_static(&goldfish_fb_info);
+}
+
+type_init(goldfish_fb_register);
diff --git a/hw/display/meson.build b/hw/display/meson.build
index 9d79e3951d..f9765417f8 100644
--- a/hw/display/meson.build
+++ b/hw/display/meson.build
@@ -21,6 +21,7 @@ softmmu_ss.add(when: 'CONFIG_VGA_ISA', if_true: files('vga-isa.c'))
 softmmu_ss.add(when: 'CONFIG_VGA_ISA_MM', if_true: files('vga-isa-mm.c'))
 softmmu_ss.add(when: 'CONFIG_VMWARE_VGA', if_true: files('vmware_vga.c'))
 softmmu_ss.add(when: 'CONFIG_BOCHS_DISPLAY', if_true: files('bochs-display.c'))
+softmmu_ss.add(when: 'CONFIG_GOLDFISH_FB', if_true: files('goldfish_fb.c'))
 
 softmmu_ss.add(when: 'CONFIG_BLIZZARD', if_true: files('blizzard.c'))
 softmmu_ss.add(when: 'CONFIG_EXYNOS4', if_true: files('exynos4210_fimd.c'))
diff --git a/include/hw/display/goldfish_fb.h b/include/hw/display/goldfish_fb.h
new file mode 100644
index 0000000000..93a3591620
--- /dev/null
+++ b/include/hw/display/goldfish_fb.h
@@ -0,0 +1,25 @@
+/*
+ * Goldfish Framebuffer public declarations.
+ *
+ * Copyright (C) 2014 Alex Bennée <alex.bennee@linaor.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef HW_DISPLAY_GOLDFISH_FB_H
+#define HW_DISPLAY_GOLDFISH_FB_H
+
+void goldfish_fb_set_rotation(int rotation);
+void goldfish_fb_set_use_host_gpu(int enabled);
+void goldfish_fb_set_display_depth(int depth);
+
+#endif /* HW_DISPLAY_GOLDFISH_FB_H */
diff --git a/include/hw/display/goldfish_fb_template.h b/include/hw/display/goldfish_fb_template.h
new file mode 100644
index 0000000000..b75534fc4e
--- /dev/null
+++ b/include/hw/display/goldfish_fb_template.h
@@ -0,0 +1,93 @@
+/*
+ *  QEMU model of the Goldfish framebuffer: drawing templates.
+ *
+ *  Copyright (c) 2014 Linaro Limited
+ *
+ * Based heavily on the milkymist drawing templates, which are:
+ *
+ *  Copyright (c) 2010 Michael Walle <michael@walle.cc>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if DEST_BITS == 8
+#define COPY_PIXEL(to, r, g, b)                    \
+    do {                                           \
+        *to = rgb_to_pixel8(r, g, b);              \
+    } while (0)
+#elif DEST_BITS == 15
+#define COPY_PIXEL(to, r, g, b)                    \
+    do {                                           \
+        *(uint16_t *)to = rgb_to_pixel15(r, g, b); \
+    } while (0)
+#elif DEST_BITS == 16
+#define COPY_PIXEL(to, r, g, b)                    \
+    do {                                           \
+        *(uint16_t *)to = rgb_to_pixel16(r, g, b); \
+    } while (0)
+#elif DEST_BITS == 24
+#define COPY_PIXEL(to, r, g, b)                    \
+    do {                                           \
+        uint32_t tmp = rgb_to_pixel24(r, g, b);    \
+        to[0] =         tmp & 0xff;              \
+        to[1] =  (tmp >> 8) & 0xff;              \
+        to[2] = (tmp >> 16) & 0xff;              \
+    } while (0)
+#elif DEST_BITS == 32
+#define COPY_PIXEL(to, r, g, b)                    \
+    do {                                           \
+        *(uint32_t *)to = rgb_to_pixel32(r, g, b); \
+    } while (0)
+#else
+#error unknown dest bit format
+#endif
+
+static void glue(glue(draw_line_, SOURCE_BITS), glue(_, DEST_BITS))(void *opaque, uint8_t *d, const uint8_t *s,
+        int width, int deststep)
+{
+#if SOURCE_BITS == 16
+    uint16_t rgb565;
+    uint8_t r, g, b;
+
+    while (width--) {
+        rgb565 = lduw_le_p(s);
+        r = ((rgb565 >> 11) & 0x1f) << 3;
+        g = ((rgb565 >>  5) & 0x3f) << 2;
+        b = ((rgb565 >>  0) & 0x1f) << 3;
+        COPY_PIXEL(d, r, g, b);
+        d += deststep;
+        s += 2;
+    }
+#elif SOURCE_BITS == 32
+    uint32_t rgbx8888;
+    uint8_t r, g, b;
+
+    while (width--) {
+        rgbx8888 = *(uint32_t*)(s);
+        b = ((rgbx8888 >> 16) & 0xff);
+        g = ((rgbx8888 >>  8) & 0xff);
+        r = ((rgbx8888 >>  0) & 0xff);
+        COPY_PIXEL(d, r, g, b);
+        d += deststep;
+        s += 4;
+    }
+#else
+#error unknown source bit format
+#endif
+}
+
+#undef DEST_BITS
+#undef SOURCE_BITS
+#undef COPY_PIXEL
diff --git a/include/sysemu/ranchu.h b/include/sysemu/ranchu.h
new file mode 100644
index 0000000000..49c7c807b1
--- /dev/null
+++ b/include/sysemu/ranchu.h
@@ -0,0 +1,41 @@
+/*
+ * ARM Android emulator 'ranchu' board.
+ *
+ * Copyright (c) 2014 Linaro Limited
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Emulate a virtual board for use as part of the Android emulator.
+ * We create a device tree to pass to the kernel.
+ * The board has a mixture of virtio devices and some Android-specific
+ * devices inherited from the 32 bit 'goldfish' board.
+ *
+ * We only support 64-bit ARM CPUs.
+ */
+
+/**
+ * callback for special handling of device tree
+ */
+#define ARCH_GIC_MAINT_IRQ  9
+#define ARCH_TIMER_VIRT_IRQ   11
+#define ARCH_TIMER_S_EL1_IRQ  13
+#define ARCH_TIMER_NS_EL1_IRQ 14
+#define ARCH_TIMER_NS_EL2_IRQ 10
+#define VIRTUAL_PMU_IRQ 7
+
+typedef void (*QemuDeviceTreeSetupFunc)(void *);
+void qemu_device_tree_setup_callback(QemuDeviceTreeSetupFunc setup_func);
+
+typedef void (*QemuDeviceTreeSetupFunc)(void *);
+void qemu_device_tree_setup_callback2(QemuDeviceTreeSetupFunc setup_func);
+
-- 
2.25.1

