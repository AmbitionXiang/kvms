From 1bcc5157a7a6249b2c5962bfff2d3ce5459bbb43 Mon Sep 17 00:00:00 2001
From: Janne Karhunen <Janne.Karhunen@gmail.com>
Date: Mon, 15 May 2023 14:12:07 +0300
Subject: [PATCH] mm: external memory allocator draft (kernel 6+)

When the guest VMs communicate with the host system via virtio, the
memory for the communication channel is allocated from the guest
memory space. The allocations are scattered all around the memory
and they relatively difficult to track accurately. This patch moves
all those allocations into configurable memory region that may reside
outside of the guest kernel.

In the modern virtualization systems the guest memory is either
separated from the host via the MMU shadow pages tables or encrypted
against the malicious host access. This leads to the guests having to
specifically request every page that the host needs to access either
to be decrypted or opened via set_memory_decrypted() architecture
extension.

Scattering the virtio memory all over the guest memory space and
opening them one by one leads to multiple problems for the hypervisor:
1) Simple hypervisor memory access control policies become impossible
   as each shared region has to be tracked separately,
2) Simple usage of the DMA api may lead to unneeded pages being shared
   with the host exposing the guest to attacks / data leakage,
3) The shadow page tables explode in size as the shared regions usually
   cannot be described via large block descriptors,
4) Allocated shared object alignment may be difficult to verify such
   that nothing extra is shared with the host.

This patch attempts to resolve all of the above by introducing a new
kmalloc flag that can be used to allocate memory from a 'open' memory
pool that may reside anywhere in the device memory that the guest and
the host have permission to access.

Signed-off-by: Janne Karhunen <Janne.Karhunen@gmail.com>
---
 arch/arm64/configs/defconfig            | 271 ++++--------------------
 drivers/block/virtio_blk.c              |  12 +-
 drivers/char/virtio_console.c           |  22 +-
 drivers/gpu/drm/virtio/virtgpu_object.c |   2 +-
 drivers/gpu/drm/virtio/virtgpu_vq.c     |   2 +-
 drivers/irqchip/irq-gic-v3-its.c        |  18 +-
 drivers/virtio/virtio_mmio.c            |   6 +-
 drivers/virtio/virtio_ring.c            | 117 ++++++++--
 include/linux/emem.h                    |  41 ++++
 include/linux/gfp.h                     |   4 +
 include/linux/gfp_types.h               |  16 +-
 include/linux/slab.h                    |  26 ++-
 include/linux/virtio_config.h           |   3 +-
 include/trace/events/mmflags.h          |   6 +-
 init/main.c                             |   7 +
 kernel/dma/contiguous.c                 |  12 ++
 kernel/dma/direct.c                     |  16 +-
 kernel/dma/mapping.c                    |   1 +
 lib/scatterlist.c                       |   6 +
 mm/Kconfig                              |  15 ++
 mm/Makefile                             |   1 +
 mm/emem.c                               | 182 ++++++++++++++++
 mm/mempool.c                            |   1 +
 mm/page_alloc.c                         |  15 ++
 mm/slab_common.c                        |   3 +
 mm/slub.c                               |   5 +
 tools/perf/builtin-kmem.c               |   1 +
 27 files changed, 531 insertions(+), 280 deletions(-)
 create mode 100644 include/linux/emem.h
 create mode 100644 mm/emem.c

diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index 0b6af3348e79..f163a2341733 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -36,13 +36,12 @@ CONFIG_ARCH_ALPINE=y
 CONFIG_ARCH_APPLE=y
 CONFIG_ARCH_BCM=y
 CONFIG_ARCH_BCM2835=y
-CONFIG_ARCH_BCMBCA=y
 CONFIG_ARCH_BCM_IPROC=y
-CONFIG_ARCH_BERLIN=y
+CONFIG_ARCH_BCMBCA=y
 CONFIG_ARCH_BRCMSTB=y
+CONFIG_ARCH_BERLIN=y
 CONFIG_ARCH_EXYNOS=y
 CONFIG_ARCH_K3=y
-CONFIG_ARCH_LAYERSCAPE=y
 CONFIG_ARCH_LG1K=y
 CONFIG_ARCH_HISI=y
 CONFIG_ARCH_KEEMBAY=y
@@ -50,12 +49,13 @@ CONFIG_ARCH_MEDIATEK=y
 CONFIG_ARCH_MESON=y
 CONFIG_ARCH_MVEBU=y
 CONFIG_ARCH_NXP=y
+CONFIG_ARCH_LAYERSCAPE=y
 CONFIG_ARCH_MXC=y
+CONFIG_ARCH_S32=y
 CONFIG_ARCH_NPCM=y
 CONFIG_ARCH_QCOM=y
 CONFIG_ARCH_RENESAS=y
 CONFIG_ARCH_ROCKCHIP=y
-CONFIG_ARCH_S32=y
 CONFIG_ARCH_SEATTLE=y
 CONFIG_ARCH_INTEL_SOCFPGA=y
 CONFIG_ARCH_SYNQUACER=y
@@ -112,17 +112,6 @@ CONFIG_ACPI_APEI_MEMORY_FAILURE=y
 CONFIG_ACPI_APEI_EINJ=y
 CONFIG_VIRTUALIZATION=y
 CONFIG_KVM=y
-CONFIG_CRYPTO_SHA1_ARM64_CE=y
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
-CONFIG_CRYPTO_SHA512_ARM64_CE=m
-CONFIG_CRYPTO_SHA3_ARM64=m
-CONFIG_CRYPTO_SM3_ARM64_CE=m
-CONFIG_CRYPTO_GHASH_ARM64_CE=y
-CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
-CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
-CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
-CONFIG_CRYPTO_CHACHA20_NEON=m
-CONFIG_CRYPTO_AES_ARM64_BS=m
 CONFIG_JUMP_LABEL=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
@@ -133,6 +122,7 @@ CONFIG_MEMORY_HOTREMOVE=y
 CONFIG_KSM=y
 CONFIG_MEMORY_FAILURE=y
 CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_EXT_MEMORY=y
 CONFIG_NET=y
 CONFIG_PACKET=y
 CONFIG_UNIX=y
@@ -186,16 +176,11 @@ CONFIG_NET_ACT_GATE=m
 CONFIG_QRTR_SMD=m
 CONFIG_QRTR_TUN=m
 CONFIG_CAN=m
-CONFIG_CAN_FLEXCAN=m
-CONFIG_CAN_RCAR=m
-CONFIG_CAN_RCAR_CANFD=m
-CONFIG_CAN_MCP251XFD=m
 CONFIG_BT=m
 CONFIG_BT_HIDP=m
 # CONFIG_BT_LE is not set
 CONFIG_BT_LEDS=y
 # CONFIG_BT_DEBUGFS is not set
-CONFIG_BT_HCIBTUSB=m
 CONFIG_BT_HCIUART=m
 CONFIG_BT_HCIUART_LL=y
 CONFIG_BT_HCIUART_BCM=y
@@ -306,7 +291,6 @@ CONFIG_AHCI_XGENE=y
 CONFIG_AHCI_QORIQ=y
 CONFIG_SATA_SIL24=y
 CONFIG_SATA_RCAR=y
-CONFIG_PATA_PLATFORM=y
 CONFIG_PATA_OF_PLATFORM=y
 CONFIG_MD=y
 CONFIG_BLK_DEV_MD=m
@@ -362,34 +346,29 @@ CONFIG_SMSC911X=y
 CONFIG_SNI_AVE=y
 CONFIG_SNI_NETSEC=y
 CONFIG_STMMAC_ETH=m
-CONFIG_DWMAC_TEGRA=m
 CONFIG_TI_K3_AM65_CPSW_NUSS=y
 CONFIG_QCOM_IPA=m
 CONFIG_MESON_GXL_PHY=m
 CONFIG_AQUANTIA_PHY=y
+CONFIG_AX88796B_PHY=m
 CONFIG_BCM54140_PHY=m
 CONFIG_MARVELL_PHY=m
 CONFIG_MARVELL_10G_PHY=m
 CONFIG_MICREL_PHY=y
+CONFIG_MICROCHIP_PHY=m
 CONFIG_MICROSEMI_PHY=y
 CONFIG_AT803X_PHY=y
 CONFIG_REALTEK_PHY=y
 CONFIG_ROCKCHIP_PHY=y
+CONFIG_SMSC_PHY=m
 CONFIG_DP83867_PHY=y
 CONFIG_VITESSE_PHY=y
+CONFIG_CAN_FLEXCAN=m
+CONFIG_CAN_RCAR=m
+CONFIG_CAN_RCAR_CANFD=m
+CONFIG_CAN_MCP251XFD=m
 CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
 CONFIG_MDIO_BUS_MUX_MMIOREG=y
-CONFIG_USB_PEGASUS=m
-CONFIG_USB_RTL8150=m
-CONFIG_USB_RTL8152=m
-CONFIG_USB_LAN78XX=m
-CONFIG_USB_USBNET=m
-CONFIG_USB_NET_DM9601=m
-CONFIG_USB_NET_SR9800=m
-CONFIG_USB_NET_SMSC75XX=m
-CONFIG_USB_NET_SMSC95XX=m
-CONFIG_USB_NET_PLUSB=m
-CONFIG_USB_NET_MCS7830=m
 CONFIG_ATH10K=m
 CONFIG_ATH10K_PCI=m
 CONFIG_ATH10K_SNOC=m
@@ -422,40 +401,10 @@ CONFIG_INPUT_HISI_POWERKEY=y
 # CONFIG_SERIO_SERPORT is not set
 CONFIG_SERIO_AMBAKMI=y
 CONFIG_LEGACY_PTY_COUNT=16
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_EXTENDED=y
-CONFIG_SERIAL_8250_SHARE_IRQ=y
-CONFIG_SERIAL_8250_BCM2835AUX=y
-CONFIG_SERIAL_8250_DW=y
-CONFIG_SERIAL_8250_EM=y
-CONFIG_SERIAL_8250_OMAP=y
-CONFIG_SERIAL_8250_MT6577=y
-CONFIG_SERIAL_8250_UNIPHIER=y
-CONFIG_SERIAL_OF_PLATFORM=y
 CONFIG_SERIAL_AMBA_PL011=y
 CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
-CONFIG_SERIAL_MESON=y
-CONFIG_SERIAL_MESON_CONSOLE=y
-CONFIG_SERIAL_SAMSUNG=y
-CONFIG_SERIAL_SAMSUNG_CONSOLE=y
-CONFIG_SERIAL_TEGRA=y
-CONFIG_SERIAL_TEGRA_TCU=y
-CONFIG_SERIAL_IMX=y
-CONFIG_SERIAL_IMX_CONSOLE=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_MSM=y
-CONFIG_SERIAL_MSM_CONSOLE=y
-CONFIG_SERIAL_QCOM_GENI=y
-CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
-CONFIG_SERIAL_XILINX_PS_UART=y
-CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
-CONFIG_SERIAL_FSL_LPUART=y
-CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
-CONFIG_SERIAL_FSL_LINFLEXUART=y
-CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE=y
-CONFIG_SERIAL_MVEBU_UART=y
-CONFIG_SERIAL_OWL=y
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_HVC_XEN is not set
 CONFIG_SERIAL_DEV_BUS=y
 CONFIG_VIRTIO_CONSOLE=y
 CONFIG_IPMI_HANDLER=m
@@ -463,6 +412,7 @@ CONFIG_IPMI_DEVICE_INTERFACE=m
 CONFIG_IPMI_SI=m
 CONFIG_TCG_TPM=y
 CONFIG_TCG_TIS_I2C_INFINEON=y
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_MUX=y
 CONFIG_I2C_MUX_PCA954x=y
@@ -520,6 +470,8 @@ CONFIG_SPI_TEGRA210_QUAD=m
 CONFIG_SPI_TEGRA114=m
 CONFIG_SPI_SPIDEV=m
 CONFIG_SPMI=y
+CONFIG_PPS=y
+# CONFIG_PTP_1588_CLOCK is not set
 CONFIG_PINCTRL_MAX77620=y
 CONFIG_PINCTRL_SINGLE=y
 CONFIG_PINCTRL_OWL=y
@@ -626,6 +578,7 @@ CONFIG_ARM_SBSA_WATCHDOG=y
 CONFIG_S3C2410_WATCHDOG=y
 CONFIG_DW_WATCHDOG=y
 CONFIG_SUNXI_WATCHDOG=m
+CONFIG_NPCM7XX_WATCHDOG=y
 CONFIG_IMX2_WDT=y
 CONFIG_IMX_SC_WDT=m
 CONFIG_QCOM_WDT=m
@@ -638,7 +591,6 @@ CONFIG_UNIPHIER_WATCHDOG=y
 CONFIG_PM8916_WATCHDOG=m
 CONFIG_BCM2835_WDT=y
 CONFIG_BCM7038_WDT=m
-CONFIG_NPCM7XX_WATCHDOG=y
 CONFIG_MFD_ALTERA_SYSMGR=y
 CONFIG_MFD_BD9571MWV=y
 CONFIG_MFD_AXP20X_I2C=y
@@ -653,6 +605,7 @@ CONFIG_MFD_SPMI_PMIC=y
 CONFIG_MFD_RK808=y
 CONFIG_MFD_SEC_CORE=y
 CONFIG_MFD_SL28CPLD=y
+CONFIG_MFD_WM8994=m
 CONFIG_MFD_ROHM_BD718XX=y
 CONFIG_MFD_WCD934X=m
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
@@ -693,8 +646,6 @@ CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
 CONFIG_MEDIA_SDR_SUPPORT=y
 CONFIG_MEDIA_PLATFORM_SUPPORT=y
 # CONFIG_DVB_NET is not set
-CONFIG_MEDIA_USB_SUPPORT=y
-CONFIG_USB_VIDEO_CLASS=m
 CONFIG_V4L_PLATFORM_DRIVERS=y
 CONFIG_SDR_PLATFORM_DRIVERS=y
 CONFIG_V4L_MEM2MEM_DRIVERS=y
@@ -711,6 +662,7 @@ CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC=m
 CONFIG_VIDEO_SAMSUNG_S5P_JPEG=m
 CONFIG_VIDEO_SAMSUNG_S5P_MFC=m
 CONFIG_VIDEO_SUN6I_CSI=m
+CONFIG_VIDEO_HANTRO=m
 CONFIG_VIDEO_IMX219=m
 CONFIG_VIDEO_OV5640=m
 CONFIG_VIDEO_OV5645=m
@@ -736,11 +688,7 @@ CONFIG_ROCKCHIP_INNO_HDMI=y
 CONFIG_ROCKCHIP_LVDS=y
 CONFIG_DRM_RCAR_DU=m
 CONFIG_DRM_RCAR_DW_HDMI=m
-CONFIG_DRM_RCAR_MIPI_DSI=m
 CONFIG_DRM_SUN4I=m
-CONFIG_DRM_SUN6I_DSI=m
-CONFIG_DRM_SUN8I_DW_HDMI=m
-CONFIG_DRM_SUN8I_MIXER=m
 CONFIG_DRM_MSM=m
 CONFIG_DRM_TEGRA=m
 CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=m
@@ -761,13 +709,10 @@ CONFIG_DRM_SIMPLE_BRIDGE=m
 CONFIG_DRM_THINE_THC63LVD1024=m
 CONFIG_DRM_TI_SN65DSI86=m
 CONFIG_DRM_I2C_ADV7511=m
-CONFIG_DRM_I2C_ADV7511_AUDIO=y
 CONFIG_DRM_CDNS_MHDP8546=m
-CONFIG_DRM_DW_HDMI_AHB_AUDIO=m
 CONFIG_DRM_DW_HDMI_CEC=m
 CONFIG_DRM_IMX_DCSS=m
 CONFIG_DRM_V3D=m
-CONFIG_DRM_VC4=m
 CONFIG_DRM_ETNAVIV=m
 CONFIG_DRM_HISI_HIBMC=m
 CONFIG_DRM_HISI_KIRIN=m
@@ -787,142 +732,10 @@ CONFIG_BACKLIGHT_LP855X=m
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=y
-CONFIG_SND_HDA_TEGRA=m
-CONFIG_SND_HDA_CODEC_HDMI=m
-CONFIG_SND_SOC=y
-CONFIG_SND_BCM2835_SOC_I2S=m
-CONFIG_SND_SOC_FSL_ASRC=m
-CONFIG_SND_SOC_FSL_MICFIL=m
-CONFIG_SND_SOC_FSL_EASRC=m
-CONFIG_SND_IMX_SOC=m
-CONFIG_SND_SOC_IMX_SGTL5000=m
-CONFIG_SND_SOC_IMX_SPDIF=m
-CONFIG_SND_SOC_FSL_ASOC_CARD=m
-CONFIG_SND_SOC_IMX_AUDMIX=m
-CONFIG_SND_MESON_AXG_SOUND_CARD=m
-CONFIG_SND_MESON_GX_SOUND_CARD=m
-CONFIG_SND_SOC_QCOM=m
-CONFIG_SND_SOC_APQ8016_SBC=m
-CONFIG_SND_SOC_MSM8996=m
-CONFIG_SND_SOC_SDM845=m
-CONFIG_SND_SOC_SM8250=m
-CONFIG_SND_SOC_SC7180=m
-CONFIG_SND_SOC_SC7280=m
-CONFIG_SND_SOC_ROCKCHIP=m
-CONFIG_SND_SOC_ROCKCHIP_SPDIF=m
-CONFIG_SND_SOC_ROCKCHIP_RT5645=m
-CONFIG_SND_SOC_RK3399_GRU_SOUND=m
-CONFIG_SND_SOC_SAMSUNG=y
-CONFIG_SND_SOC_RCAR=m
-CONFIG_SND_SOC_RZ=m
-CONFIG_SND_SUN8I_CODEC=m
-CONFIG_SND_SUN8I_CODEC_ANALOG=m
-CONFIG_SND_SUN50I_CODEC_ANALOG=m
-CONFIG_SND_SUN4I_I2S=m
-CONFIG_SND_SUN4I_SPDIF=m
-CONFIG_SND_SOC_TEGRA=m
-CONFIG_SND_SOC_TEGRA210_AHUB=m
-CONFIG_SND_SOC_TEGRA210_DMIC=m
-CONFIG_SND_SOC_TEGRA210_I2S=m
-CONFIG_SND_SOC_TEGRA210_OPE=m
-CONFIG_SND_SOC_TEGRA186_ASRC=m
-CONFIG_SND_SOC_TEGRA186_DSPK=m
-CONFIG_SND_SOC_TEGRA210_ADMAIF=m
-CONFIG_SND_SOC_TEGRA210_MVC=m
-CONFIG_SND_SOC_TEGRA210_SFC=m
-CONFIG_SND_SOC_TEGRA210_AMX=m
-CONFIG_SND_SOC_TEGRA210_ADX=m
-CONFIG_SND_SOC_TEGRA210_MIXER=m
-CONFIG_SND_SOC_TEGRA_AUDIO_GRAPH_CARD=m
-CONFIG_SND_SOC_AK4613=m
-CONFIG_SND_SOC_ES7134=m
-CONFIG_SND_SOC_ES7241=m
-CONFIG_SND_SOC_GTM601=m
-CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
-CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
-CONFIG_SND_SOC_PCM3168A_I2C=m
-CONFIG_SND_SOC_RT5659=m
-CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
-CONFIG_SND_SOC_SIMPLE_MUX=m
-CONFIG_SND_SOC_TAS571X=m
-CONFIG_SND_SOC_TLV320AIC32X4_I2C=m
-CONFIG_SND_SOC_WCD9335=m
-CONFIG_SND_SOC_WCD934X=m
-CONFIG_SND_SOC_WM8524=m
-CONFIG_SND_SOC_WM8904=m
-CONFIG_SND_SOC_WM8960=m
-CONFIG_SND_SOC_WM8962=m
-CONFIG_SND_SOC_WM8978=m
-CONFIG_SND_SOC_WSA881X=m
-CONFIG_SND_SOC_NAU8822=m
-CONFIG_SND_SOC_LPASS_WSA_MACRO=m
-CONFIG_SND_SOC_LPASS_VA_MACRO=m
-CONFIG_SND_SOC_LPASS_RX_MACRO=m
-CONFIG_SND_SOC_LPASS_TX_MACRO=m
-CONFIG_SND_SIMPLE_CARD=m
-CONFIG_SND_AUDIO_GRAPH_CARD=m
-CONFIG_SND_AUDIO_GRAPH_CARD2=m
 CONFIG_HID_MULTITOUCH=m
 CONFIG_I2C_HID_ACPI=m
 CONFIG_I2C_HID_OF=m
-CONFIG_USB=y
-CONFIG_USB_OTG=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_PCI_RENESAS=m
-CONFIG_USB_XHCI_TEGRA=y
-CONFIG_USB_BRCMSTB=m
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_EXYNOS=y
-CONFIG_USB_EHCI_HCD_PLATFORM=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_EXYNOS=y
-CONFIG_USB_OHCI_HCD_PLATFORM=y
-CONFIG_USB_RENESAS_USBHS_HCD=m
-CONFIG_USB_RENESAS_USBHS=m
-CONFIG_USB_ACM=m
-CONFIG_USB_STORAGE=y
-CONFIG_USB_CDNS_SUPPORT=m
-CONFIG_USB_CDNS3=m
-CONFIG_USB_CDNS3_GADGET=y
-CONFIG_USB_CDNS3_HOST=y
-CONFIG_USB_MTU3=y
-CONFIG_USB_MUSB_HDRC=y
-CONFIG_USB_MUSB_SUNXI=y
-CONFIG_USB_DWC3=y
-CONFIG_USB_DWC2=y
-CONFIG_USB_CHIPIDEA=y
-CONFIG_USB_CHIPIDEA_UDC=y
-CONFIG_USB_CHIPIDEA_HOST=y
-CONFIG_USB_ISP1760=y
-CONFIG_USB_SERIAL=m
-CONFIG_USB_SERIAL_CP210X=m
-CONFIG_USB_SERIAL_FTDI_SIO=m
-CONFIG_USB_SERIAL_OPTION=m
-CONFIG_USB_HSIC_USB3503=y
-CONFIG_NOP_USB_XCEIV=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_RENESAS_USBHS_UDC=m
-CONFIG_USB_RENESAS_USB3=m
-CONFIG_USB_TEGRA_XUDC=m
-CONFIG_USB_CONFIGFS=m
-CONFIG_USB_CONFIGFS_SERIAL=y
-CONFIG_USB_CONFIGFS_ACM=y
-CONFIG_USB_CONFIGFS_OBEX=y
-CONFIG_USB_CONFIGFS_NCM=y
-CONFIG_USB_CONFIGFS_ECM=y
-CONFIG_USB_CONFIGFS_ECM_SUBSET=y
-CONFIG_USB_CONFIGFS_RNDIS=y
-CONFIG_USB_CONFIGFS_EEM=y
-CONFIG_USB_CONFIGFS_MASS_STORAGE=y
-CONFIG_USB_CONFIGFS_F_FS=y
-CONFIG_TYPEC=m
-CONFIG_TYPEC_TCPM=m
-CONFIG_TYPEC_TCPCI=m
-CONFIG_TYPEC_FUSB302=m
-CONFIG_TYPEC_TPS6598X=m
-CONFIG_TYPEC_HD3SS3220=m
+# CONFIG_USB_SUPPORT is not set
 CONFIG_MMC=y
 CONFIG_MMC_BLOCK_MINORS=32
 CONFIG_MMC_ARMMMCI=y
@@ -930,8 +743,8 @@ CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_ACPI=y
 CONFIG_MMC_SDHCI_PLTFM=y
 CONFIG_MMC_SDHCI_OF_ARASAN=y
-CONFIG_MMC_SDHCI_OF_DWCMSHC=y
 CONFIG_MMC_SDHCI_OF_ESDHC=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
 CONFIG_MMC_SDHCI_CADENCE=y
 CONFIG_MMC_SDHCI_ESDHC_IMX=y
 CONFIG_MMC_SDHCI_TEGRA=y
@@ -1029,12 +842,12 @@ CONFIG_VFIO=y
 CONFIG_VFIO_PCI=y
 CONFIG_VIRTIO_PCI=y
 CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
 CONFIG_VIRTIO_MMIO=y
 CONFIG_XEN_GNTDEV=y
 CONFIG_XEN_GRANT_DEV_ALLOC=y
 CONFIG_STAGING=y
 CONFIG_STAGING_MEDIA=y
-CONFIG_VIDEO_HANTRO=m
 CONFIG_VIDEO_IMX_MEDIA=m
 CONFIG_VIDEO_MAX96712=m
 CONFIG_CHROME_PLATFORMS=y
@@ -1050,7 +863,6 @@ CONFIG_COMMON_CLK_FSL_SAI=y
 CONFIG_COMMON_CLK_S2MPS11=y
 CONFIG_COMMON_CLK_PWM=y
 CONFIG_COMMON_CLK_VC5=y
-CONFIG_COMMON_CLK_NPCM8XX=y
 CONFIG_COMMON_CLK_BD718XX=m
 CONFIG_CLK_RASPBERRYPI=m
 CONFIG_CLK_IMX8MM=y
@@ -1061,6 +873,7 @@ CONFIG_CLK_IMX8QXP=y
 CONFIG_CLK_IMX8ULP=y
 CONFIG_CLK_IMX93=y
 CONFIG_TI_SCI_CLK=y
+CONFIG_COMMON_CLK_AXG_AUDIO=m
 CONFIG_COMMON_CLK_QCOM=y
 CONFIG_QCOM_A53PLL=y
 CONFIG_QCOM_CLK_APCS_MSM8916=y
@@ -1118,7 +931,6 @@ CONFIG_RPMSG_QCOM_GLINK_RPM=y
 CONFIG_RPMSG_QCOM_GLINK_SMEM=m
 CONFIG_RPMSG_QCOM_SMD=y
 CONFIG_SOUNDWIRE=m
-CONFIG_SOUNDWIRE_QCOM=m
 CONFIG_OWL_PM_DOMAINS=y
 CONFIG_RASPBERRYPI_POWER=y
 CONFIG_FSL_DPAA=y
@@ -1216,12 +1028,13 @@ CONFIG_PWM_VISCONTI=m
 CONFIG_SL28CPLD_INTC=y
 CONFIG_QCOM_PDC=y
 CONFIG_RESET_IMX7=y
+CONFIG_RESET_MESON_AUDIO_ARB=m
 CONFIG_RESET_QCOM_AOSS=y
 CONFIG_RESET_QCOM_PDC=m
+CONFIG_RESET_RASPBERRYPI=m
 CONFIG_RESET_RZG2L_USBPHY_CTRL=y
 CONFIG_RESET_TI_SCI=y
 CONFIG_PHY_XGENE=y
-CONFIG_PHY_SUN4I_USB=y
 CONFIG_PHY_CADENCE_TORRENT=m
 CONFIG_PHY_CADENCE_SIERRA=m
 CONFIG_PHY_MIXEL_MIPI_DPHY=m
@@ -1235,23 +1048,19 @@ CONFIG_PHY_QCOM_EDP=m
 CONFIG_PHY_QCOM_PCIE2=m
 CONFIG_PHY_QCOM_QMP=m
 CONFIG_PHY_QCOM_QUSB2=m
-CONFIG_PHY_QCOM_USB_HS=m
 CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=m
 CONFIG_PHY_QCOM_USB_HS_28NM=m
 CONFIG_PHY_QCOM_USB_SS=m
 CONFIG_PHY_RCAR_GEN3_PCIE=y
-CONFIG_PHY_RCAR_GEN3_USB2=y
 CONFIG_PHY_RCAR_GEN3_USB3=m
 CONFIG_PHY_ROCKCHIP_EMMC=y
 CONFIG_PHY_ROCKCHIP_INNO_HDMI=m
-CONFIG_PHY_ROCKCHIP_INNO_USB2=y
 CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY=m
 CONFIG_PHY_ROCKCHIP_PCIE=m
 CONFIG_PHY_ROCKCHIP_TYPEC=y
 CONFIG_PHY_SAMSUNG_UFS=y
 CONFIG_PHY_UNIPHIER_USB2=y
 CONFIG_PHY_UNIPHIER_USB3=y
-CONFIG_PHY_TEGRA_XUSB=y
 CONFIG_PHY_AM654_SERDES=m
 CONFIG_PHY_J721E_WIZ=m
 CONFIG_ARM_CCI_PMU=m
@@ -1260,21 +1069,21 @@ CONFIG_ARM_CMN=m
 CONFIG_ARM_SMMU_V3_PMU=m
 CONFIG_ARM_DSU_PMU=m
 CONFIG_FSL_IMX8_DDR_PMU=m
-CONFIG_ARM_SPE_PMU=m
-CONFIG_ARM_DMC620_PMU=m
 CONFIG_QCOM_L2_PMU=y
 CONFIG_QCOM_L3_PMU=y
+CONFIG_ARM_SPE_PMU=m
+CONFIG_ARM_DMC620_PMU=m
 CONFIG_HISI_PMU=y
 CONFIG_NVMEM_IMX_OCOTP=y
 CONFIG_NVMEM_IMX_OCOTP_SCU=y
+CONFIG_NVMEM_LAYERSCAPE_SFP=m
+CONFIG_NVMEM_MESON_EFUSE=m
 CONFIG_NVMEM_MTK_EFUSE=y
 CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_NVMEM_RMEM=m
 CONFIG_NVMEM_ROCKCHIP_EFUSE=y
 CONFIG_NVMEM_SUNXI_SID=y
 CONFIG_NVMEM_UNIPHIER_EFUSE=y
-CONFIG_NVMEM_MESON_EFUSE=m
-CONFIG_NVMEM_RMEM=m
-CONFIG_NVMEM_LAYERSCAPE_SFP=m
 CONFIG_FPGA=y
 CONFIG_FPGA_MGR_ALTERA_CVP=m
 CONFIG_FPGA_MGR_STRATIX10_SOC=m
@@ -1288,7 +1097,6 @@ CONFIG_MUX_MMIO=y
 CONFIG_SLIMBUS=m
 CONFIG_SLIM_QCOM_CTRL=m
 CONFIG_SLIM_QCOM_NGD_CTRL=m
-CONFIG_INTERCONNECT=y
 CONFIG_INTERCONNECT_IMX=m
 CONFIG_INTERCONNECT_IMX8MM=m
 CONFIG_INTERCONNECT_IMX8MN=m
@@ -1316,13 +1124,13 @@ CONFIG_FANOTIFY=y
 CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
 CONFIG_QUOTA=y
 CONFIG_AUTOFS4_FS=y
-CONFIG_FUSE_FS=m
-CONFIG_CUSE=m
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_VIRTIO_FS=y
 CONFIG_OVERLAY_FS=m
 CONFIG_VFAT_FS=y
 CONFIG_TMPFS_POSIX_ACL=y
 CONFIG_HUGETLBFS=y
-CONFIG_CONFIGFS_FS=y
 CONFIG_EFIVAR_FS=y
 CONFIG_SQUASHFS=y
 CONFIG_NFS_FS=y
@@ -1338,6 +1146,17 @@ CONFIG_CRYPTO_ECHAINIV=y
 CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_ANSI_CPRNG=y
 CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_BS=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
 CONFIG_CRYPTO_DEV_SUN8I_CE=m
 CONFIG_CRYPTO_DEV_FSL_CAAM=m
 CONFIG_CRYPTO_DEV_FSL_DPAA2_CAAM=m
diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index a7697027ce43..bc7be214a9c7 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -141,7 +141,7 @@ static int virtblk_setup_discard_write_zeroes_erase(struct request *req, bool un
 	if (unmap)
 		flags |= VIRTIO_BLK_WRITE_ZEROES_FLAG_UNMAP;
 
-	range = kmalloc_array(segments, sizeof(*range), GFP_ATOMIC);
+	range = kmalloc_array(segments, sizeof(*range), GFP_ATOMIC | GFP_EXT);
 	if (!range)
 		return -ENOMEM;
 
@@ -644,17 +644,18 @@ static int init_vq(struct virtio_blk *vblk)
 				vblk->io_queues[HCTX_TYPE_READ],
 				vblk->io_queues[HCTX_TYPE_POLL]);
 
-	vblk->vqs = kmalloc_array(num_vqs, sizeof(*vblk->vqs), GFP_KERNEL);
+	vblk->vqs = kmalloc_array(num_vqs, sizeof(*vblk->vqs), GFP_KERNEL | GFP_EXT);
 	if (!vblk->vqs)
 		return -ENOMEM;
 
-	names = kmalloc_array(num_vqs, sizeof(*names), GFP_KERNEL);
-	callbacks = kmalloc_array(num_vqs, sizeof(*callbacks), GFP_KERNEL);
-	vqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL);
+	names = kmalloc_array(num_vqs, sizeof(*names), GFP_KERNEL | GFP_EXT);
+	callbacks = kmalloc_array(num_vqs, sizeof(*callbacks), GFP_KERNEL | GFP_EXT);
+	vqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL | GFP_EXT);
 	if (!names || !callbacks || !vqs) {
 		err = -ENOMEM;
 		goto out;
 	}
+	pr_err("0x%llx 0x%llx 0x%llx 0x%llx\n", (u64)vblk->vqs, (u64)names, (u64)callbacks, (u64)vqs);
 
 	for (i = 0; i < num_vqs - num_poll_vqs; i++) {
 		callbacks[i] = virtblk_done;
@@ -1152,6 +1153,7 @@ static int virtblk_probe(struct virtio_device *vdev)
 	virtblk_update_capacity(vblk, false);
 	virtio_device_ready(vdev);
 
+	pr_err("device_add_disk()\n");
 	err = device_add_disk(&vdev->dev, vblk->disk, virtblk_attr_groups);
 	if (err)
 		goto out_cleanup_disk;
diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c
index 9fa3c76a267f..f09618c0c0b5 100644
--- a/drivers/char/virtio_console.c
+++ b/drivers/char/virtio_console.c
@@ -421,7 +421,7 @@ static struct port_buffer *alloc_buf(struct virtio_device *vdev, size_t buf_size
 	 * Allocate buffer and the sg list. The sg list array is allocated
 	 * directly after the port_buffer struct.
 	 */
-	buf = kmalloc(struct_size(buf, sg, pages), GFP_KERNEL);
+	buf = kmalloc(struct_size(buf, sg, pages), GFP_KERNEL | GFP_EXT);
 	if (!buf)
 		goto fail;
 
@@ -446,10 +446,10 @@ static struct port_buffer *alloc_buf(struct virtio_device *vdev, size_t buf_size
 		/* Increase device refcnt to avoid freeing it */
 		get_device(buf->dev);
 		buf->buf = dma_alloc_coherent(buf->dev, buf_size, &buf->dma,
-					      GFP_KERNEL);
+					      GFP_KERNEL | GFP_EXT);
 	} else {
 		buf->dev = NULL;
-		buf->buf = kmalloc(buf_size, GFP_KERNEL);
+		buf->buf = kmalloc(buf_size, GFP_KERNEL | GFP_EXT);
 	}
 
 	if (!buf->buf)
@@ -1363,7 +1363,7 @@ static int add_port(struct ports_device *portdev, u32 id)
 	dev_t devt;
 	int err;
 
-	port = kmalloc(sizeof(*port), GFP_KERNEL);
+	port = kmalloc(sizeof(*port), GFP_KERNEL | GFP_EXT);
 	if (!port) {
 		err = -ENOMEM;
 		goto fail;
@@ -1664,7 +1664,7 @@ static void handle_control_message(struct virtio_device *vdev,
 		 */
 		name_size = buf->len - buf->offset - sizeof(*cpkt) + 1;
 
-		port->name = kmalloc(name_size, GFP_KERNEL);
+		port->name = kmalloc(name_size, GFP_KERNEL | GFP_EXT);
 		if (!port->name) {
 			dev_err(port->dev,
 				"Not enough space to store port name\n");
@@ -1849,14 +1849,14 @@ static int init_vqs(struct ports_device *portdev)
 	nr_ports = portdev->max_nr_ports;
 	nr_queues = use_multiport(portdev) ? (nr_ports + 1) * 2 : 2;
 
-	vqs = kmalloc_array(nr_queues, sizeof(struct virtqueue *), GFP_KERNEL);
+	vqs = kmalloc_array(nr_queues, sizeof(struct virtqueue *), GFP_KERNEL | GFP_EXT);
 	io_callbacks = kmalloc_array(nr_queues, sizeof(vq_callback_t *),
-				     GFP_KERNEL);
-	io_names = kmalloc_array(nr_queues, sizeof(char *), GFP_KERNEL);
+				     GFP_KERNEL | GFP_EXT);
+	io_names = kmalloc_array(nr_queues, sizeof(char *), GFP_KERNEL | GFP_EXT);
 	portdev->in_vqs = kmalloc_array(nr_ports, sizeof(struct virtqueue *),
-					GFP_KERNEL);
+					GFP_KERNEL | GFP_EXT);
 	portdev->out_vqs = kmalloc_array(nr_ports, sizeof(struct virtqueue *),
-					 GFP_KERNEL);
+					 GFP_KERNEL | GFP_EXT);
 	if (!vqs || !io_callbacks || !io_names || !portdev->in_vqs ||
 	    !portdev->out_vqs) {
 		err = -ENOMEM;
@@ -2016,7 +2016,7 @@ static int virtcons_probe(struct virtio_device *vdev)
 	/* Ensure to read early_put_chars now */
 	barrier();
 
-	portdev = kmalloc(sizeof(*portdev), GFP_KERNEL);
+	portdev = kmalloc(sizeof(*portdev), GFP_KERNEL | GFP_EXT);
 	if (!portdev) {
 		err = -ENOMEM;
 		goto fail;
diff --git a/drivers/gpu/drm/virtio/virtgpu_object.c b/drivers/gpu/drm/virtio/virtgpu_object.c
index c7e74cf13022..46de18947fd3 100644
--- a/drivers/gpu/drm/virtio/virtgpu_object.c
+++ b/drivers/gpu/drm/virtio/virtgpu_object.c
@@ -153,7 +153,7 @@ static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,
 
 	*ents = kvmalloc_array(*nents,
 			       sizeof(struct virtio_gpu_mem_entry),
-			       GFP_KERNEL);
+			       GFP_KERNEL | GFP_EXT);
 	if (!(*ents)) {
 		DRM_ERROR("failed to allocate ent list\n");
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/virtio/virtgpu_vq.c b/drivers/gpu/drm/virtio/virtgpu_vq.c
index 208e9434cb28..7b2046f282bd 100644
--- a/drivers/gpu/drm/virtio/virtgpu_vq.c
+++ b/drivers/gpu/drm/virtio/virtgpu_vq.c
@@ -93,7 +93,7 @@ virtio_gpu_get_vbuf(struct virtio_gpu_device *vgdev,
 {
 	struct virtio_gpu_vbuffer *vbuf;
 
-	vbuf = kmem_cache_zalloc(vgdev->vbufs, GFP_KERNEL | __GFP_NOFAIL);
+	vbuf = kmem_cache_zalloc(vgdev->vbufs, GFP_KERNEL | __GFP_NOFAIL | GFP_EXT);
 
 	BUG_ON(size > MAX_INLINE_CMD_SIZE ||
 	       size < sizeof(struct virtio_gpu_ctrl_hdr));
diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index 973ede0197e3..50c4185b4f54 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -2178,7 +2178,7 @@ static struct page *its_allocate_prop_table(gfp_t gfp_flags)
 {
 	struct page *prop_page;
 
-	prop_page = alloc_pages(gfp_flags, get_order(LPI_PROPBASE_SZ));
+	prop_page = alloc_pages(gfp_flags | GFP_EXT, get_order(LPI_PROPBASE_SZ));
 	if (!prop_page)
 		return NULL;
 
@@ -2312,7 +2312,8 @@ static int its_setup_baser(struct its_node *its, struct its_baser *baser,
 		order = get_order(GITS_BASER_PAGES_MAX * psz);
 	}
 
-	page = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO, order);
+	page = alloc_pages_node(its->numa_node, GFP_KERNEL | GFP_EXT |
+				__GFP_ZERO, order);
 	if (!page)
 		return -ENOMEM;
 
@@ -2778,7 +2779,7 @@ static bool allocate_vpe_l2_table(int cpu, u32 id)
 
 	/* Allocate memory for 2nd level table */
 	if (!table[idx]) {
-		page = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(psz));
+		page = alloc_pages(GFP_KERNEL | GFP_EXT | __GFP_ZERO, get_order(psz));
 		if (!page)
 			return false;
 
@@ -2830,7 +2831,7 @@ static int allocate_vpe_l1_table(void)
 	if (val & GICR_VPROPBASER_4_1_VALID)
 		goto out;
 
-	gic_data_rdist()->vpe_table_mask = kzalloc(sizeof(cpumask_t), GFP_ATOMIC);
+	gic_data_rdist()->vpe_table_mask = kzalloc(sizeof(cpumask_t), GFP_ATOMIC | GFP_EXT);
 	if (!gic_data_rdist()->vpe_table_mask)
 		return -ENOMEM;
 
@@ -2941,7 +2942,7 @@ static struct page *its_allocate_pending_table(gfp_t gfp_flags)
 {
 	struct page *pend_page;
 
-	pend_page = alloc_pages(gfp_flags | __GFP_ZERO,
+	pend_page = alloc_pages(gfp_flags | GFP_EXT | __GFP_ZERO,
 				get_order(LPI_PENDBASE_SZ));
 	if (!pend_page)
 		return NULL;
@@ -3283,8 +3284,8 @@ static bool its_alloc_table_entry(struct its_node *its,
 
 	/* Allocate memory for 2nd level table */
 	if (!table[idx]) {
-		page = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO,
-					get_order(baser->psz));
+		page = alloc_pages_node(its->numa_node, GFP_KERNEL | GFP_EXT |
+					__GFP_ZERO, get_order(baser->psz));
 		if (!page)
 			return false;
 
@@ -5064,7 +5065,8 @@ static int __init its_probe_one(struct resource *res,
 
 	its->numa_node = numa_node;
 
-	page = alloc_pages_node(its->numa_node, GFP_KERNEL | __GFP_ZERO,
+	page = alloc_pages_node(its->numa_node,
+				GFP_KERNEL | GFP_EXT | __GFP_ZERO,
 				get_order(ITS_CMD_QUEUE_SZ));
 	if (!page) {
 		err = -ENOMEM;
diff --git a/drivers/virtio/virtio_mmio.c b/drivers/virtio/virtio_mmio.c
index 3ff746e3f24a..5811b983bb39 100644
--- a/drivers/virtio/virtio_mmio.c
+++ b/drivers/virtio/virtio_mmio.c
@@ -383,7 +383,7 @@ static struct virtqueue *vm_setup_vq(struct virtio_device *vdev, unsigned int in
 	}
 
 	/* Allocate and fill out our active queue description */
-	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	info = kmalloc(sizeof(*info), GFP_KERNEL | GFP_EXT);
 	if (!info) {
 		err = -ENOMEM;
 		goto error_kmalloc;
@@ -409,6 +409,7 @@ static struct virtqueue *vm_setup_vq(struct virtio_device *vdev, unsigned int in
 	writel(virtqueue_get_vring_size(vq), vm_dev->base + VIRTIO_MMIO_QUEUE_NUM);
 	if (vm_dev->version == 1) {
 		u64 q_pfn = virtqueue_get_desc_addr(vq) >> PAGE_SHIFT;
+		pr_info("using LEGACY desc ring at 0x%llx\n", virtqueue_get_desc_addr(vq));
 
 		/*
 		 * virtio-mmio v1 uses a 32bit QUEUE PFN. If we have something
@@ -429,16 +430,19 @@ static struct virtqueue *vm_setup_vq(struct virtio_device *vdev, unsigned int in
 		u64 addr;
 
 		addr = virtqueue_get_desc_addr(vq);
+		pr_info("desc ring at 0x%llx\n", addr);
 		writel((u32)addr, vm_dev->base + VIRTIO_MMIO_QUEUE_DESC_LOW);
 		writel((u32)(addr >> 32),
 				vm_dev->base + VIRTIO_MMIO_QUEUE_DESC_HIGH);
 
 		addr = virtqueue_get_avail_addr(vq);
+		pr_info("avail ring at 0x%llx\n", addr);
 		writel((u32)addr, vm_dev->base + VIRTIO_MMIO_QUEUE_AVAIL_LOW);
 		writel((u32)(addr >> 32),
 				vm_dev->base + VIRTIO_MMIO_QUEUE_AVAIL_HIGH);
 
 		addr = virtqueue_get_used_addr(vq);
+		pr_info("used ring at 0x%llx\n", addr);
 		writel((u32)addr, vm_dev->base + VIRTIO_MMIO_QUEUE_USED_LOW);
 		writel((u32)(addr >> 32),
 				vm_dev->base + VIRTIO_MMIO_QUEUE_USED_HIGH);
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 90d514c14179..848e8be3f6f9 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -14,6 +14,7 @@
 #include <linux/kmsan.h>
 #include <linux/spinlock.h>
 #include <xen/xen.h>
+#include <linux/emem.h>
 
 #ifdef DEBUG
 /* For development, we want to crash whenever the ring is screwed. */
@@ -232,6 +233,7 @@ static void vring_free(struct virtqueue *_vq);
 static inline bool virtqueue_use_indirect(struct vring_virtqueue *vq,
 					  unsigned int total_sg)
 {
+	return false;
 	/*
 	 * If the host supports indirect descriptor tables, and we have multiple
 	 * buffers, then go indirect. FIXME: tune this threshold
@@ -299,8 +301,11 @@ EXPORT_SYMBOL_GPL(virtio_max_dma_size);
 static void *vring_alloc_queue(struct virtio_device *vdev, size_t size,
 			      dma_addr_t *dma_handle, gfp_t flag)
 {
+	void *ret;
+
+	flag |= GFP_EXT;
 	if (vring_use_dma_api(vdev)) {
-		return dma_alloc_coherent(vdev->dev.parent, size,
+		ret = dma_alloc_coherent(vdev->dev.parent, size,
 					  dma_handle, flag);
 	} else {
 		void *queue = alloc_pages_exact(PAGE_ALIGN(size), flag);
@@ -325,8 +330,16 @@ static void *vring_alloc_queue(struct virtio_device *vdev, size_t size,
 				return NULL;
 			}
 		}
-		return queue;
+		ret = queue;
 	}
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem(ret))
+		BUG();
+
+	pr_info("vring_alloc_queue(): allocated 0x%llx/0x%llx\n", (u64)ret,
+		*dma_handle);
+#endif
+	return ret;
 }
 
 static void vring_free_queue(struct virtio_device *vdev, size_t size,
@@ -473,9 +486,10 @@ static struct vring_desc *alloc_indirect_split(struct virtqueue *_vq,
 	 * We require lowmem mappings for the descriptors because
 	 * otherwise virt_to_phys will give us bogus addresses in the
 	 * virtqueue.
+	 *
+	 * FIXME: ^^^^^. For now we don't support indirects,
+	 * virtqueue_use_indirect is hardcoded to return false.
 	 */
-	gfp &= ~__GFP_HIGHMEM;
-
 	desc = kmalloc_array(total_sg, sizeof(struct vring_desc), gfp);
 	if (!desc)
 		return NULL;
@@ -649,6 +663,12 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 	else
 		vq->split.desc_state[head].indir_desc = ctx;
 
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem_dma((dma_addr_t)vq->split.desc_state[head].indir_desc->addr))
+		BUG();
+	pr_err("buf head at 0x%llx\n", (u64)vq->split.desc_state[head].indir_desc->addr);
+#endif
+
 	/* Put entry in available array (but don't update avail->idx until they
 	 * do sync). */
 	avail = vq->split.avail_idx_shadow & (vq->split.vring.num - 1);
@@ -1019,7 +1039,7 @@ static int vring_alloc_state_extra_split(struct vring_virtqueue_split *vring_spl
 	struct vring_desc_extra *extra;
 	u32 num = vring_split->vring.num;
 
-	state = kmalloc_array(num, sizeof(struct vring_desc_state_split), GFP_KERNEL);
+	state = kmalloc_array(num, sizeof(struct vring_desc_state_split), GFP_KERNEL | GFP_EXT);
 	if (!state)
 		goto err_state;
 
@@ -1228,7 +1248,7 @@ static struct vring_packed_desc *alloc_indirect_packed(unsigned int total_sg,
 	 * otherwise virt_to_phys will give us bogus addresses in the
 	 * virtqueue.
 	 */
-	gfp &= ~__GFP_HIGHMEM;
+	gfp &= GFP_EXT;
 
 	desc = kmalloc_array(total_sg, sizeof(struct vring_packed_desc), gfp);
 
@@ -1844,7 +1864,7 @@ static struct vring_desc_extra *vring_alloc_desc_extra(unsigned int num)
 	unsigned int i;
 
 	desc_extra = kmalloc_array(num, sizeof(struct vring_desc_extra),
-				   GFP_KERNEL);
+				   GFP_KERNEL | GFP_EXT);
 	if (!desc_extra)
 		return NULL;
 
@@ -1917,6 +1937,15 @@ static int vring_alloc_queue_packed(struct vring_virtqueue_packed *vring_packed,
 	if (!device)
 		goto err;
 
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem(ring))
+		pr_err("0x%llx ring is not emem addr\n", (u64)ring);
+	if (!is_emem(driver))
+		pr_err("0x%llx driver is not emem addr\n", (u64)driver);
+	if (!is_emem(device))
+		pr_err("0x%llx device is not emem addr\n", (u64)device);
+#endif
+
 	vring_packed->vring.device          = device;
 	vring_packed->device_event_dma_addr = device_event_dma_addr;
 
@@ -1935,7 +1964,7 @@ static int vring_alloc_state_extra_packed(struct vring_virtqueue_packed *vring_p
 	struct vring_desc_extra *extra;
 	u32 num = vring_packed->vring.num;
 
-	state = kmalloc_array(num, sizeof(struct vring_desc_state_packed), GFP_KERNEL);
+	state = kmalloc_array(num, sizeof(struct vring_desc_state_packed), GFP_KERNEL | GFP_EXT);
 	if (!state)
 		goto err_desc_state;
 
@@ -1945,6 +1974,11 @@ static int vring_alloc_state_extra_packed(struct vring_virtqueue_packed *vring_p
 	if (!extra)
 		goto err_desc_extra;
 
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem(extra))
+		pr_err("0x%llx extra is not emem addr\n", (u64)extra);
+#endif
+
 	vring_packed->desc_state = state;
 	vring_packed->desc_extra = extra;
 
@@ -2012,7 +2046,7 @@ static struct virtqueue *vring_create_virtqueue_packed(
 	if (vring_alloc_queue_packed(&vring_packed, vdev, num))
 		goto err_ring;
 
-	vq = kmalloc(sizeof(*vq), GFP_KERNEL);
+	vq = kmalloc(sizeof(*vq), GFP_KERNEL | GFP_EXT);
 	if (!vq)
 		goto err_vq;
 
@@ -2107,6 +2141,7 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
+	gfp |= GFP_EXT;
 	return vq->packed_ring ? virtqueue_add_packed(_vq, sgs, total_sg,
 					out_sgs, in_sgs, data, ctx, gfp) :
 				 virtqueue_add_split(_vq, sgs, total_sg,
@@ -2136,6 +2171,7 @@ int virtqueue_add_sgs(struct virtqueue *_vq,
 {
 	unsigned int i, total_sg = 0;
 
+	gfp |= GFP_EXT;
 	/* Count them first. */
 	for (i = 0; i < out_sgs + in_sgs; i++) {
 		struct scatterlist *sg;
@@ -2166,6 +2202,12 @@ int virtqueue_add_outbuf(struct virtqueue *vq,
 			 void *data,
 			 gfp_t gfp)
 {
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem_dma(sg_dma_address(sg)))
+		BUG();
+
+	gfp |= GFP_EXT;
+#endif
 	return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_outbuf);
@@ -2188,6 +2230,12 @@ int virtqueue_add_inbuf(struct virtqueue *vq,
 			void *data,
 			gfp_t gfp)
 {
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem_dma(sg_dma_address(sg)))
+		BUG();
+
+	gfp |= GFP_EXT;
+#endif
 	return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_inbuf);
@@ -2212,6 +2260,7 @@ int virtqueue_add_inbuf_ctx(struct virtqueue *vq,
 			void *ctx,
 			gfp_t gfp)
 {
+	gfp |= GFP_EXT;
 	return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_inbuf_ctx);
@@ -2499,7 +2548,7 @@ static struct virtqueue *__vring_new_virtqueue(unsigned int index,
 	if (virtio_has_feature(vdev, VIRTIO_F_RING_PACKED))
 		return NULL;
 
-	vq = kmalloc(sizeof(*vq), GFP_KERNEL);
+	vq = kmalloc(sizeof(*vq), GFP_KERNEL | GFP_EXT);
 	if (!vq)
 		return NULL;
 
@@ -2828,41 +2877,73 @@ EXPORT_SYMBOL_GPL(__virtio_unbreak_device);
 dma_addr_t virtqueue_get_desc_addr(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
+	dma_addr_t addr;
 
 	BUG_ON(!vq->we_own_ring);
 
 	if (vq->packed_ring)
-		return vq->packed.ring_dma_addr;
+		addr = vq->packed.ring_dma_addr;
+	else
+		addr = vq->split.queue_dma_addr;
+
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem_dma(addr))
+		pr_err("0x%llx desc vq is not emem dma addr\n", (u64)addr);
+	else
+		pr_err("0x%llx desc vq is emem\n", (u64)addr);
+#endif
 
-	return vq->split.queue_dma_addr;
+	return addr;
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_desc_addr);
 
 dma_addr_t virtqueue_get_avail_addr(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
+	dma_addr_t addr;
 
 	BUG_ON(!vq->we_own_ring);
 
 	if (vq->packed_ring)
-		return vq->packed.driver_event_dma_addr;
+		addr = vq->packed.driver_event_dma_addr;
+	else
+		addr = vq->split.queue_dma_addr +
+			((char *)vq->split.vring.avail -
+			(char *)vq->split.vring.desc);
 
-	return vq->split.queue_dma_addr +
-		((char *)vq->split.vring.avail - (char *)vq->split.vring.desc);
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem_dma(addr))
+		pr_err("0x%llx avail vq is not emem dma addr\n", (u64)addr);
+	else
+		pr_err("0x%llx avail vq is emem\n", (u64)addr);
+#endif
+
+	return addr;
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_avail_addr);
 
 dma_addr_t virtqueue_get_used_addr(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
+	dma_addr_t addr;
 
 	BUG_ON(!vq->we_own_ring);
 
 	if (vq->packed_ring)
-		return vq->packed.device_event_dma_addr;
+		addr = vq->packed.device_event_dma_addr;
+	else
+		addr = vq->split.queue_dma_addr +
+			((char *)vq->split.vring.used -
+			(char *)vq->split.vring.desc);
+
+#ifdef CONFIG_EXT_MEMORY
+	if (!is_emem_dma(addr))
+		pr_err("0x%llx used vq is not emem dma addr\n", (u64)addr);
+	else
+		pr_err("0x%llx used vq is emem\n", (u64)addr);
+#endif
 
-	return vq->split.queue_dma_addr +
-		((char *)vq->split.vring.used - (char *)vq->split.vring.desc);
+	return addr;
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_used_addr);
 
diff --git a/include/linux/emem.h b/include/linux/emem.h
new file mode 100644
index 000000000000..3eb13828314c
--- /dev/null
+++ b/include/linux/emem.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __MM_EMEM_H__
+#define __MM_EMEM_H__
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <asm/dma.h>
+
+struct emem_region {
+	unsigned long *bitmap;
+	unsigned int npages;
+	unsigned int bits;
+	phys_addr_t dma_base;
+	u64 base;
+};
+
+extern struct emem_region emem;
+extern spinlock_t emem_lock;
+
+#ifdef CONFIG_EXT_MEMORY
+int __init emem_region_init(void);
+int is_emem(void *vaddr);
+int is_emem_dma(dma_addr_t addr);
+struct page *emem_getpages_unlocked(gfp_t flags, int order);
+struct page *emem_getpages(gfp_t flags, int order);
+void emem_freepages(struct page *page, int order);
+#else
+static inline int __init emem_region_init(void) { return 0 };
+static inline int is_emem(void *vaddr) { return 0; };
+static inline int is_emem_dma(dma_addr_t addr) { return 0; };
+static inline struct page *emem_getpages_unlocked(gfp_t flags, int order)
+{
+	return NULL;
+};
+static inline struct page *emem_getpages(gfp_t flags, int order)
+{
+	return NULL;
+};
+static inline void emem_freepages(struct page *page, int order) { };
+#endif
+#endif // __MM_EMEM_H__
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 65a78773dcca..fab4e7cc80c7 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -54,6 +54,10 @@ static inline bool gfpflags_allow_blocking(const gfp_t gfp_flags)
 #define OPT_ZONE_DMA32 ZONE_NORMAL
 #endif
 
+#ifdef CONFIG_ZONE_EXT
+#define OPT_ZONE_EXT ZONE_EXT
+#endif
+
 /*
  * GFP_ZONE_TABLE is a word size bitstring that is used for looking up the
  * zone to use given the lowest 4 bits of gfp_t. Entries are GFP_ZONES_SHIFT
diff --git a/include/linux/gfp_types.h b/include/linux/gfp_types.h
index d88c46ca82e1..946a027088ee 100644
--- a/include/linux/gfp_types.h
+++ b/include/linux/gfp_types.h
@@ -60,6 +60,12 @@ typedef unsigned int __bitwise gfp_t;
 #else
 #define ___GFP_NOLOCKDEP	0
 #endif
+#ifdef CONFIG_EXT_MEMORY
+#define ___GFP_EXT		0x10000000u
+#else
+#define ___GFP_EXT		0
+#endif
+
 /* If the above are modified, __GFP_BITS_SHIFT may need updating */
 
 /*
@@ -255,8 +261,11 @@ typedef unsigned int __bitwise gfp_t;
 /* Disable lockdep for GFP context tracking */
 #define __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)
 
+/* Shared external allocation */
+#define __GFP_EXT	((__force gfp_t)___GFP_EXT)
+
 /* Room for N __GFP_FOO bits */
-#define __GFP_BITS_SHIFT (27 + IS_ENABLED(CONFIG_LOCKDEP))
+#define __GFP_BITS_SHIFT (28 + IS_ENABLED(CONFIG_EXT_MEMORY))
 #define __GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))
 
 /**
@@ -313,6 +322,10 @@ typedef unsigned int __bitwise gfp_t;
  * because the DMA32 kmalloc cache array is not implemented.
  * (Reason: there is no such user in kernel).
  *
+ * %GFP_EXT indicates that this allocation should be done from an external
+ * memory pool added via the memory hotplug. This allocation type requires
+ * separate configuration and cannot be used without it.
+ *
  * %GFP_HIGHUSER is for userspace allocations that may be mapped to userspace,
  * do not need to be directly accessible by the kernel but that cannot
  * move once in use. An example may be a hardware allocation that maps
@@ -338,6 +351,7 @@ typedef unsigned int __bitwise gfp_t;
 #define GFP_USER	(__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
 #define GFP_DMA		__GFP_DMA
 #define GFP_DMA32	__GFP_DMA32
+#define GFP_EXT		__GFP_EXT
 #define GFP_HIGHUSER	(GFP_USER | __GFP_HIGHMEM)
 #define GFP_HIGHUSER_MOVABLE	(GFP_HIGHUSER | __GFP_MOVABLE | \
 			 __GFP_SKIP_KASAN_POISON | __GFP_SKIP_KASAN_UNPOISON)
diff --git a/include/linux/slab.h b/include/linux/slab.h
index 45efc6c553b8..9bcfbf944f2e 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -114,6 +114,12 @@
 #define SLAB_KASAN		0
 #endif
 
+#ifdef CONFIG_EXT_MEMORY
+#define SLAB_CACHE_EXT		((slab_flags_t __force)0x20000000U)
+#else
+#define SLAB_CACHE_EXT		0
+#endif
+
 /*
  * Ignore user specified debugging flags.
  * Intended for caches created for self-tests so they have only flags
@@ -149,6 +155,7 @@
 
 struct list_lru;
 struct mem_cgroup;
+
 /*
  * struct kmem_cache related prototypes
  */
@@ -338,6 +345,11 @@ enum kmalloc_cache_type {
 	KMALLOC_CGROUP = KMALLOC_NORMAL,
 #else
 	KMALLOC_CGROUP,
+#endif
+#ifdef CONFIG_ZONE_EXT
+	KMALLOC_EXT,
+#else
+	KMALLOC_EXT = KMALLOC_NORMAL,
 #endif
 	KMALLOC_RECLAIM,
 #ifdef CONFIG_ZONE_DMA
@@ -356,7 +368,8 @@ kmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1];
 #define KMALLOC_NOT_NORMAL_BITS					\
 	(__GFP_RECLAIMABLE |					\
 	(IS_ENABLED(CONFIG_ZONE_DMA)   ? __GFP_DMA : 0) |	\
-	(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0))
+	(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0) |	\
+	(IS_ENABLED(CONFIG_EXT_MEMORY) ? __GFP_EXT : 0))
 
 static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)
 {
@@ -371,11 +384,14 @@ static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)
 	 * At least one of the flags has to be set. Their priorities in
 	 * decreasing order are:
 	 *  1) __GFP_DMA
-	 *  2) __GFP_RECLAIMABLE
-	 *  3) __GFP_ACCOUNT
+	 *  2) __GFP_EXT
+	 *  3) __GFP_RECLAIMABLE
+	 *  4) __GFP_ACCOUNT
 	 */
 	if (IS_ENABLED(CONFIG_ZONE_DMA) && (flags & __GFP_DMA))
 		return KMALLOC_DMA;
+	if (IS_ENABLED(CONFIG_ZONE_EXT) && (flags & __GFP_EXT))
+		return KMALLOC_EXT;
 	if (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags & __GFP_RECLAIMABLE))
 		return KMALLOC_RECLAIM;
 	else
@@ -535,6 +551,10 @@ void *kmalloc_large_node(size_t size, gfp_t flags, int node) __assume_page_align
  * %__GFP_RETRY_MAYFAIL
  *	Try really hard to succeed the allocation but fail
  *	eventually.
+ *
+ * %__GFP_EXT
+ *	This allocation should be done from an external memory pool.
+ *
  */
 static __always_inline __alloc_size(1) void *kmalloc(size_t size, gfp_t flags)
 {
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index 4b517649cfe8..44f24aabe26d 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -201,7 +201,8 @@ static inline bool virtio_has_dma_quirk(const struct virtio_device *vdev)
 	 * Note the reverse polarity of the quirk feature (compared to most
 	 * other features), this is for compatibility with legacy systems.
 	 */
-	return !virtio_has_feature(vdev, VIRTIO_F_ACCESS_PLATFORM);
+	return false;
+	//return !virtio_has_feature(vdev, VIRTIO_F_ACCESS_PLATFORM);
 }
 
 static inline
diff --git a/include/trace/events/mmflags.h b/include/trace/events/mmflags.h
index e87cb2b80ed3..3cfa1dd77b3e 100644
--- a/include/trace/events/mmflags.h
+++ b/include/trace/events/mmflags.h
@@ -2,6 +2,7 @@
 #include <linux/node.h>
 #include <linux/mmzone.h>
 #include <linux/compaction.h>
+
 /*
  * The order of these masks is important. Matching masks will be seen
  * first and the left over flags will end up showing by themselves.
@@ -30,6 +31,7 @@
 	gfpflag_string(GFP_DMA),		\
 	gfpflag_string(__GFP_HIGHMEM),		\
 	gfpflag_string(GFP_DMA32),		\
+	gfpflag_string(__GFP_EXT),		\
 	gfpflag_string(__GFP_HIGH),		\
 	gfpflag_string(__GFP_ATOMIC),		\
 	gfpflag_string(__GFP_IO),		\
@@ -51,13 +53,13 @@
 	gfpflag_string(__GFP_RECLAIM),		\
 	gfpflag_string(__GFP_DIRECT_RECLAIM),	\
 	gfpflag_string(__GFP_KSWAPD_RECLAIM),	\
-	gfpflag_string(__GFP_ZEROTAGS)
+	gfpflag_string(__GFP_ZEROTAGS)		\
 
 #ifdef CONFIG_KASAN_HW_TAGS
 #define __def_gfpflag_names_kasan ,			\
 	gfpflag_string(__GFP_SKIP_ZERO),		\
 	gfpflag_string(__GFP_SKIP_KASAN_POISON),	\
-	gfpflag_string(__GFP_SKIP_KASAN_UNPOISON)
+	gfpflag_string(__GFP_SKIP_KASAN_UNPOISON),	\
 #else
 #define __def_gfpflag_names_kasan
 #endif
diff --git a/init/main.c b/init/main.c
index aa21add5f7c5..f21a698cc899 100644
--- a/init/main.c
+++ b/init/main.c
@@ -101,6 +101,7 @@
 #include <linux/init_syscalls.h>
 #include <linux/stackdepot.h>
 #include <linux/randomize_kstack.h>
+#include <linux/emem.h>
 #include <net/net_namespace.h>
 
 #include <asm/io.h>
@@ -1035,6 +1036,12 @@ asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
 	if (initcall_debug)
 		initcall_debug_enable();
 
+	/*
+	 * Needs to happen before the irq init as we may need to share
+	 * some memory for the irq controller itself.
+	 */
+        emem_region_init();
+
 	context_tracking_init();
 	/* init some links before init_ISA_irqs() */
 	early_irq_init();
diff --git a/kernel/dma/contiguous.c b/kernel/dma/contiguous.c
index 6ea80ae42622..894c8d3b4201 100644
--- a/kernel/dma/contiguous.c
+++ b/kernel/dma/contiguous.c
@@ -50,6 +50,7 @@
 #include <linux/sizes.h>
 #include <linux/dma-map-ops.h>
 #include <linux/cma.h>
+#include <linux/emem.h>
 
 #ifdef CONFIG_CMA_SIZE_MBYTES
 #define CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES
@@ -303,10 +304,21 @@ static struct page *cma_alloc_aligned(struct cma *cma, size_t size, gfp_t gfp)
  */
 struct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp)
 {
+	struct page *page;
+
 #ifdef CONFIG_DMA_PERNUMA_CMA
 	int nid = dev_to_node(dev);
 #endif
 
+	if (unlikely(gfp & __GFP_EXT)) {
+		page = emem_getpages(gfp, get_order(size));
+		if (!page) {
+			pr_err("emem_getpages out of memory?\n");
+			return NULL;
+		}
+		return page;
+	}
+
 	/* CMA can be used only in the context which permits sleeping */
 	if (!gfpflags_allow_blocking(gfp))
 		return NULL;
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index 63859a101ed8..4fef889469f6 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -13,6 +13,7 @@
 #include <linux/vmalloc.h>
 #include <linux/set_memory.h>
 #include <linux/slab.h>
+#include <linux/emem.h>
 #include "direct.h"
 
 /*
@@ -126,8 +127,9 @@ static struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,
 	if (is_swiotlb_for_alloc(dev))
 		return dma_direct_alloc_swiotlb(dev, size);
 
-	gfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,
-					   &phys_limit);
+	if (!(gfp & GFP_EXT))
+		gfp |= dma_direct_optimal_gfp_mask(dev, dev->coherent_dma_mask,
+						   &phys_limit);
 	page = dma_alloc_contiguous(dev, size, gfp);
 	if (page) {
 		if (!dma_coherent_ok(dev, page_to_phys(page), size) ||
@@ -370,6 +372,16 @@ struct page *dma_direct_alloc_pages(struct device *dev, size_t size,
 	struct page *page;
 	void *ret;
 
+	if (unlikely(gfp & __GFP_EXT)) {
+		page = emem_getpages(gfp, get_order(size));
+		if (!page) {
+			pr_err("emem_getpages out of memory?\n");
+			return NULL;
+		}
+		*dma_handle = page_to_phys(page);
+		return page;
+	}
+
 	if (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))
 		return dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);
 
diff --git a/kernel/dma/mapping.c b/kernel/dma/mapping.c
index 33437d620644..b0aeea7073e9 100644
--- a/kernel/dma/mapping.c
+++ b/kernel/dma/mapping.c
@@ -14,6 +14,7 @@
 #include <linux/of_device.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
+#include <linux/emem.h>
 #include "debug.h"
 #include "direct.h"
 
diff --git a/lib/scatterlist.c b/lib/scatterlist.c
index c8c3d675845c..03ae6af4c5c0 100644
--- a/lib/scatterlist.c
+++ b/lib/scatterlist.c
@@ -148,6 +148,7 @@ EXPORT_SYMBOL(sg_init_one);
  */
 static struct scatterlist *sg_kmalloc(unsigned int nents, gfp_t gfp_mask)
 {
+	gfp_mask |= GFP_EXT;
 	if (nents == SG_MAX_SINGLE_ALLOC) {
 		/*
 		 * Kmemleak doesn't track page allocations as they are not
@@ -298,6 +299,8 @@ int __sg_alloc_table(struct sg_table *table, unsigned int nents,
 		return -EINVAL;
 #endif
 
+	gfp_mask |= GFP_EXT;
+
 	left = nents;
 	prv = NULL;
 	do {
@@ -459,6 +462,8 @@ int sg_alloc_append_table_from_pages(struct sg_append_table *sgt_append,
 	if (IS_ENABLED(CONFIG_ARCH_NO_SG_CHAIN) && sgt_append->prv)
 		return -EOPNOTSUPP;
 
+	gfp_mask |= GFP_EXT;
+
 	if (sgt_append->prv) {
 		unsigned long paddr =
 			(page_to_pfn(sg_page(sgt_append->prv)) * PAGE_SIZE +
@@ -615,6 +620,7 @@ struct scatterlist *sgl_alloc_order(unsigned long long length,
 			return NULL;
 		nalloc++;
 	}
+	gfp |= GFP_EXT;
 	sgl = kmalloc_array(nalloc, sizeof(struct scatterlist),
 			    gfp & ~GFP_DMA);
 	if (!sgl)
diff --git a/mm/Kconfig b/mm/Kconfig
index 57e1d8c5b505..89f00a9f41f2 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -958,6 +958,10 @@ config ZONE_DMA32
 	depends on !X86_32
 	default y if ARM64
 
+config ZONE_EXT
+	bool "Support external allocation pool"
+	depends on MEMORY_HOTPLUG
+
 config ZONE_DEVICE
 	bool "Device memory (pmem, HMM, etc...) hotplug support"
 	depends on MEMORY_HOTPLUG
@@ -975,6 +979,17 @@ config ZONE_DEVICE
 
 	  If FS_DAX is enabled, then say Y.
 
+config EXT_MEMORY
+	bool "Support for allocations from a external memory pool"
+	select ZONE_EXT
+
+	help
+	  Support for kernel memory allocations outside of the regular
+	  kernel regions. These regions are configured separately via
+	  the device tree.
+
+	  If unsure, say N.
+
 #
 # Helpers to mirror range of the CPU page tables of a process into device page
 # tables.
diff --git a/mm/Makefile b/mm/Makefile
index 8e105e5b3e29..75d99bf588ef 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -138,3 +138,4 @@ obj-$(CONFIG_IO_MAPPING) += io-mapping.o
 obj-$(CONFIG_HAVE_BOOTMEM_INFO_NODE) += bootmem_info.o
 obj-$(CONFIG_GENERIC_IOREMAP) += ioremap.o
 obj-$(CONFIG_SHRINKER_DEBUG) += shrinker_debug.o
+obj-$(CONFIG_EXT_MEMORY) += emem.o
diff --git a/mm/emem.c b/mm/emem.c
new file mode 100644
index 000000000000..a6e823079919
--- /dev/null
+++ b/mm/emem.c
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  linux/mm/emem.c
+ */
+
+#include <linux/slab.h>
+#include <linux/memory_hotplug.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/emem.h>
+#include <linux/memblock.h>
+
+extern gfp_t gfp_allowed_mask;
+struct emem_region emem;
+DEFINE_SPINLOCK(emem_lock);
+static bool emem_init_done;
+
+static int emem_get_config(struct device_node *np, phys_addr_t *base, size_t *size)
+{
+	struct device_node *shm_np;
+	struct resource res_mem;
+	int ret;
+
+	shm_np = of_parse_phandle(np, "memory-region", 0);
+	if (!shm_np)
+		return -EINVAL;
+
+	ret = of_address_to_resource(shm_np, 0, &res_mem);
+	if (ret)
+		return -EINVAL;
+
+	*base = res_mem.start;
+	*size = resource_size(&res_mem);
+	of_node_put(shm_np);
+
+	if (!*base || !*size)
+		return -EINVAL;
+
+	pr_info("emem: shm base at 0x%llx size %lu\n", *base, *size);
+	return 0;
+}
+
+int emem_region_init(void)
+{
+	struct device_node *np;
+	phys_addr_t base;
+	unsigned long iflags;
+	int res, npages;
+	size_t size;
+
+	if (emem_init_done)
+		return 0;
+	emem_init_done = true;
+
+	spin_lock_irqsave(&emem_lock, iflags);
+	np = of_find_node_by_path("/emem_region");
+	if (!np) {
+		pr_err("emem region not configured\n");
+		res = -ENOTSUPP;
+		goto out;
+	}
+
+	res = emem_get_config(np, &base, &size);
+	of_node_put(np);
+	if (res)
+		goto out;
+
+	if ((base % PAGE_SIZE) || (size % PAGE_SIZE)) {
+		res = -EINVAL;
+		goto out;
+	}
+
+	res = add_memory(0, base, size, MMOP_OFFLINE);
+	if (res == -EEXIST) {
+		pr_warn("memory block already exists, assuming reserved\n");
+		res = 0;
+		goto cont;
+	} else if (res != 0)
+		goto out;
+
+cont:
+	/* Bookkeeping at the beginning */
+	npages = size / (PAGE_SIZE * 8);
+	emem.dma_base = base;
+	emem.bitmap = phys_to_virt(base);
+	emem.npages = (size / PAGE_SIZE) - npages;
+	emem.bits = emem.npages * PAGE_SIZE * 8;
+	emem.base = (u64)phys_to_virt(emem.dma_base) + (npages * PAGE_SIZE);
+	gfp_allowed_mask |= GFP_EXT;
+
+out:
+	if (res == 0)
+		pr_info("emem: region registered at 0x%llx successfully\n",
+			(u64)emem.base);
+	else
+		pr_err("emem: region registration failed, error %d\n", res);
+
+	spin_unlock_irqrestore(&emem_lock, iflags);
+	return res;
+}
+
+int is_emem(void *vaddr)
+{
+	u64 s, e, v = (u64)vaddr;
+
+	if (!emem.base)
+		BUG();
+
+	s = emem.base;
+	e = s + (emem.npages * PAGE_SIZE);
+	if ((v >= s) && (v < e))
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(is_emem);
+
+int is_emem_dma(dma_addr_t addr)
+{
+	u64 s, e, a = (u64)addr;
+
+	if (!emem.base)
+		BUG();
+
+	s = (u64)emem.dma_base;
+	e = s + (emem.npages * PAGE_SIZE);
+	if ((a >= s) && (a < e))
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(is_emem_dma);
+
+struct page *emem_getpages_unlocked(gfp_t flags, int order)
+{
+	struct page *page;
+	void *vaddr = NULL;
+	int pageno;
+
+	if (!emem.bitmap)
+		panic("emem_getpages() without init?\n");
+
+	pageno = bitmap_find_free_region(emem.bitmap, emem.bits, order);
+	if (pageno >= 0)
+		vaddr = (void *)emem.base + (pageno << PAGE_SHIFT);
+	if (!vaddr)
+		return NULL;
+
+	page = virt_to_page(vaddr);
+	if (!page)
+		panic("no page for allocation emem page\n");
+	return page;
+}
+EXPORT_SYMBOL_GPL(emem_getpages_unlocked);
+
+struct page *emem_getpages(gfp_t flags, int order)
+{
+	struct page *page;
+	unsigned long iflags;
+
+	spin_lock_irqsave(&emem_lock, iflags);
+	page = emem_getpages_unlocked(flags, order);
+	spin_unlock_irqrestore(&emem_lock, iflags);
+
+	return page;
+}
+EXPORT_SYMBOL_GPL(emem_getpages);
+
+void emem_freepages(struct page *page, int order)
+{
+	unsigned long irq_flags;
+	int pageno;
+
+	if (!emem.bitmap)
+		return;
+
+	pageno = (page_to_virt(page) - (void *)emem.base) >> PAGE_SHIFT;
+	page_mapcount_reset(page);
+
+	spin_lock_irqsave(&emem_lock, irq_flags);
+	bitmap_release_region(emem.bitmap, pageno, order);
+	spin_unlock_irqrestore(&emem_lock, irq_flags);
+}
+EXPORT_SYMBOL_GPL(emem_freepages);
diff --git a/mm/mempool.c b/mm/mempool.c
index 96488b13a1ef..2c8e71cb3418 100644
--- a/mm/mempool.c
+++ b/mm/mempool.c
@@ -384,6 +384,7 @@ void *mempool_alloc(mempool_t *pool, gfp_t gfp_mask)
 	gfp_mask |= __GFP_NOMEMALLOC;	/* don't allocate emergency reserves */
 	gfp_mask |= __GFP_NORETRY;	/* don't loop in __alloc_pages */
 	gfp_mask |= __GFP_NOWARN;	/* failures are OK */
+	gfp_mask |= __GFP_EXT;		/* if enabled, used it */
 
 	gfp_temp = gfp_mask & ~(__GFP_DIRECT_RECLAIM|__GFP_IO);
 
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 69668817fed3..5cbe2796c9a2 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -76,6 +76,7 @@
 #include <linux/khugepaged.h>
 #include <linux/buffer_head.h>
 #include <linux/delayacct.h>
+#include <linux/emem.h>
 #include <asm/sections.h>
 #include <asm/tlbflush.h>
 #include <asm/div64.h>
@@ -5536,6 +5537,16 @@ struct page *__alloc_pages(gfp_t gfp, unsigned int order, int preferred_nid,
 		return NULL;
 
 	gfp &= gfp_allowed_mask;
+
+	if (unlikely(gfp & __GFP_EXT)) {
+		page = emem_getpages(gfp, order);
+		if (!page) {
+			pr_err("emem_getpages out of memory?\n");
+			return NULL;
+		}
+		goto out;
+	}
+
 	/*
 	 * Apply scoped allocation constraints. This is mainly about GFP_NOFS
 	 * resp. GFP_NOIO which has to be inherited for all allocation requests
@@ -5644,6 +5655,10 @@ void __free_pages(struct page *page, unsigned int order)
 	/* get PageHead before we drop reference */
 	int head = PageHead(page);
 
+	if (unlikely(is_emem(page_to_virt(page)))) {
+		emem_freepages(page, order);
+		return;
+	}
 	if (put_page_testzero(page))
 		free_the_page(page, order);
 	else if (!head)
diff --git a/mm/slab_common.c b/mm/slab_common.c
index 0042fb2730d1..b83d60cb3015 100644
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@ -770,6 +770,7 @@ EXPORT_SYMBOL(kmalloc_size_roundup);
 {								\
 	.name[KMALLOC_NORMAL]  = "kmalloc-" #__short_size,	\
 	.name[KMALLOC_RECLAIM] = "kmalloc-rcl-" #__short_size,	\
+	.name[KMALLOC_EXT]     = "kmalloc-ext-" #__short_size,  \
 	KMALLOC_CGROUP_NAME(__short_size)			\
 	KMALLOC_DMA_NAME(__short_size)				\
 	.size = __size,						\
@@ -866,6 +867,8 @@ new_kmalloc_cache(int idx, enum kmalloc_cache_type type, slab_flags_t flags)
 	} else if (IS_ENABLED(CONFIG_ZONE_DMA) && (type == KMALLOC_DMA)) {
 		flags |= SLAB_CACHE_DMA;
 	}
+	if (type == KMALLOC_EXT)
+		flags |= SLAB_CACHE_EXT;
 
 	kmalloc_caches[type][idx] = create_kmalloc_cache(
 					kmalloc_info[idx].name[type],
diff --git a/mm/slub.c b/mm/slub.c
index 157527d7101b..d73799083860 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -4285,6 +4285,9 @@ static int calculate_sizes(struct kmem_cache *s)
 	if (s->flags & SLAB_CACHE_DMA32)
 		s->allocflags |= GFP_DMA32;
 
+	if (s->flags & SLAB_CACHE_EXT)
+		s->allocflags |= GFP_EXT;
+
 	if (s->flags & SLAB_RECLAIM_ACCOUNT)
 		s->allocflags |= __GFP_RECLAIMABLE;
 
@@ -5895,6 +5898,8 @@ static char *create_unique_id(struct kmem_cache *s)
 		*p++ = 'd';
 	if (s->flags & SLAB_CACHE_DMA32)
 		*p++ = 'D';
+	if (s->flags & SLAB_CACHE_EXT)
+		*p++ = 'E';
 	if (s->flags & SLAB_RECLAIM_ACCOUNT)
 		*p++ = 'a';
 	if (s->flags & SLAB_CONSISTENCY_CHECKS)
diff --git a/tools/perf/builtin-kmem.c b/tools/perf/builtin-kmem.c
index 40dd52acc48a..359da8a403e3 100644
--- a/tools/perf/builtin-kmem.c
+++ b/tools/perf/builtin-kmem.c
@@ -672,6 +672,7 @@ static const struct {
 	{ "__GFP_RECLAIM",		"R" },
 	{ "__GFP_DIRECT_RECLAIM",	"DR" },
 	{ "__GFP_KSWAPD_RECLAIM",	"KR" },
+	{ "__GFP_EXT",			"EXT" },
 };
 
 static size_t max_gfp_len;
-- 
2.34.1

